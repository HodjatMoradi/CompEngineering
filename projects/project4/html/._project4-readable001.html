<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Random walking dead">

<title>Random walking dead</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:64px;      /* fixed header height for style bootswatch_readable */
  margin:-64px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Introduction', 1, 'introduction', 'introduction'),
              ('Exercise 1: Solving the $SZ$ model using Monte Carlo',
               1,
               None,
               '___sec1'),
              ('Exercise 2: Random walking dead', 1, None, '___sec2'),
              ('Exercise 3: Estimating $\\beta$ and the basic reproduction '
               'number',
               1,
               None,
               '___sec3'),
              ('Exercise 4: Old and young population - who survives?',
               1,
               None,
               '___sec4'),
              ('Exercise 5: Implement your own scenario', 1, None, '___sec5'),
              ('Guidelines for project submission', 1, None, '___sec6'),
              ('Appendix: Object-oriented programming?', 1, 'app:a', 'app:a'),
              ('Appendix: The use of arrays to simulate a random walk',
               1,
               'app:b',
               'app:b'),
              ('Appendix: The combined use of classes and arrays',
               1,
               'app:c',
               'app:c'),
              ('Bibliography', 1, None, '___sec10')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="project4-readable.html">Random walking dead</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._project4-readable000.html#table_of_contents" style="font-size: 80%;">Table of contents</a></li>
     <!-- navigation toc: --> <li><a href="#introduction" style="font-size: 80%;">Introduction</a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">Exercise 1: Solving the \( SZ \) model using Monte Carlo</a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">Exercise 2: Random walking dead</a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;">Exercise 3: Estimating \( \beta \) and the basic reproduction number</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">Exercise 4: Old and young population - who survives?</a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">Exercise 5: Implement your own scenario</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">Guidelines for project submission</a></li>
     <!-- navigation toc: --> <li><a href="#app:a" style="font-size: 80%;">Appendix: Object-oriented programming?</a></li>
     <!-- navigation toc: --> <li><a href="#app:b" style="font-size: 80%;">Appendix: The use of arrays to simulate a random walk</a></li>
     <!-- navigation toc: --> <li><a href="#app:c" style="font-size: 80%;">Appendix: The combined use of classes and arrays</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0001"></a>
<!-- !split -->

<h1 id="introduction" class="anchor">Introduction</h1>

<p>
In this project we are going to gain further insight into zombie outbreaks
by using Monte Carlo (MC) simulation. Previously, we studied the spreading
of diseases with <em>compartment models</em>. Key parameters in this approach
are the probability of infection \( \beta \), and the recovery rate
\( \alpha \) (kill rate for zombies). Together these two parameters were used
to estimate the basic reproduction number \( \mathcal{R}_0 \), which provides
a measure of whether the disease will be able to spread in the population.

<p>
In project 3, we simply assumed that \( \beta \) declined exponentially as a
function of time, eventually putting an end to the disease outbreak.
However, we did not explain <em>why</em> such a rapid decline should occur, if at all.
For the particular case of the 2014 Ebola virus outbreak in Liberia,
researchers actually found that the value of \( \mathcal{R}_0 \) showed no
signs of decreasing, even 6 months after the outbreak <a href="#althaus2014">[1]</a>.
Understanding the mechanisms for how to decrease \( \beta \) is therefore
important when faced with a potential epidemic.

<p>
To make the above statement more concrete, we will in this project model
<em>interactions</em> between sick and healthy persons <em>directly</em>. In this way we
can test various assumptions, and predict how \( \beta \) and \( \alpha \) might
vary as a function of time. To this end, we shall employ
<em>random walk</em> <a href="#pearson1905problem">[2]</a> <a href="#codling2008random">[3]</a>
simulations.
We will start by solving the \( SZ \) model using a Monte Carlo approach.
Here, we will not learn anything new regarding zombie-human interactions,
because we are solving the same model as in project 3. However, you will
discover a completely different way of solving the compartment model, and
gain an appreciation for how random fluctuations can affect the final solution.

<p>
Next, we model detailed interactions between individuals in the population
using a random walk method. Based on the output from these simulations, we
predict the parameter \( \beta \) from the compartment model as a function of time,
which we subsequently compare with the original \( SZ \) model.
We also investigate the impact of various model assumptions regarding how
humans learn from surviving zombie encounters.

<p>
Finally, we add the possibility that a subset of humans move more slowly than
the rest, and explore some scenarios for how this impacts the predicted fate
of the humans.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Models at different scales.</b>
To gain a fundamental understanding of model parameters at a given
scale, one needs models at a finer scale. During the process of <em>upscaling</em>,
the output from the finer models are used to compute model parameters at
the coarser scale.
</div>


<h1 id="___sec1" class="anchor">Exercise 1: Solving the \( SZ \) model using Monte Carlo </h1>
The \( SZ \) model was described in Project 3, and is repeated here for
completeness:

$$
\begin{align}
\tag{1}
\frac{\mathrm{d}S(t)}{\mathrm{d}t}&=-\beta\cdot\frac{S(t)Z(t)}{N}\\ 
\tag{2}
\frac{\mathrm{d}Z(t)}{\mathrm{d}t}&=\frac{\mathrm{d}(N-S)}{\mathrm{d}t}
= -\frac{\mathrm{d}S(t)}{\mathrm{d}t}
=\beta\cdot\frac{S(t)Z(t)}{N}\,.
\end{align}
$$

<p>
The probability \( p_Z \) of a human (\( S \)) turning into a zombie (\( Z \)) was
given as
$$
\begin{equation}
\tag{3}
p_Z=\beta\cdot\Delta t\cdot\frac{Z(t)}{N}\,,
\end{equation}
$$

where \( N \) is the total number of humans and zombies, and \( \beta \) was put
equal to 0.06 \( 1/\text{hr} \).

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>This exercise.</b>

<ul>
<li> Let \( N=683 \), and \( Z(0)=10 \), and \( \beta=0.06 \) 1/hr.</li>
<li> Suppose that during <em>each time step</em>, <em>all</em> humans can be contacted by the zombie(s), and thus stand the chance of being infected.</li>
<li> Specifically, for each human pick a random number \( u \) between (0,1). If \( u < p_z \), convert the human to a zombie, i.e, update \( Z=Z+1 \), and \( S=S-1 \).</li>
<li> Whenever a human is turned into a zombie update \( p_z \) according to equation <a href="#mjx-eqn-3">(3)</a></li> 
</ul>
</div>


<p>
<b>Part 1.</b>

<ul>
<li> Make a code that uses the algorithm described above to predict the fate of humans and zombies</li>
</ul>

<b>Part 2.</b>

<ul>
<li> Run the code 100-1000 times, and use the output to calculate the mean and standard deviation of the number of humans and zombies at each moment in time.</li>
<li> Present the results in a figure, where you illustrate how the randomness in the simulations appear in the solution 

<ol type="a"></li>
 <li> A figure in which you plot the mean value plus/minus one standard deviation (you may use, e.g., <a href="https://jakevdp.github.io/PythonDataScienceHandbook/04.03-errorbars.html" target="_self"><tt>plt.fill_between</tt></a>.)</li>
 <li> Also include the analytical solution in the plot.</li>
 <li> Make a histogram of the survivors after 100 hours</li>
</ol>

</ul>

See figure <a href="#fig:p4:mc">1</a> for how a possible solution might look like.

<p>
<center> <!-- figure label: --> <div id="fig:p4:mc"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  (left) Evolution of zombie and human as a function of time, \( Z(0)=10 \) (right) A histogram showing the distribution of survivors and zombies at a specific moment in time. (1000 simulations was used)  <!-- caption label: fig:p4:mc --> </p></center>
<p><img src="fig-project4/SI_mc_comb.png" align="bottom" width=400></p>
</center>

<p>
<b>Part 3.</b>

<ul>
<li> Repeat the simulation above, but this time start with \( Z(0)=1 \). What is the difference, now compared to when \( Z(0)=10 \)? Would you say that the MC simulation is more ''correct'' than the continuum (analytical) solution?</li>
</ul>

<h1 id="___sec2" class="anchor">Exercise 2: Random walking dead </h1>

<p>
<center> <!-- figure label: --> <div id="fig:p4:znmr"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  (left) Zombies and humans confined on an island, (right) MRI signal from a healthy brain.  <!-- caption label: fig:p4:znmr --> </p></center>
<p><img src="fig-project4/zomb_nmr.png" align="bottom" width=400></p>
</center>

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Random walking dead and nuclear magnetic resonance (NMR).</b>
The model you are going to develop is not that different from models describing NMR and magnetic resonance imaging (MRI). In MRI, all the magnetic spins are excited to a higher energy level. Then they move randomly (like random walk), whenever they bump into each other there is a probability that they fall into a lower energy level. The MRI machine measure the time it takes before all the spins returns to the original state. If the spins are confined in e.g. cells they will return to the lower,, original, energy state faster. Water contains more spins and will give a higher intensity signal, see figure <a href="#fig:p4:znmr">2</a>, where the MRI image is <a href="https://en.wikipedia.org/wiki/Magnetic_resonance_imaging" target="_self">from</a>.
</div>

We are going to investigate the interactions between humans and zombies in
more detail to get a deeper understanding of the \( \beta \) value in the
compartment model. You are going to implement the following algorithm:

<ul>
<li> Humans and zombies are confined to a finite, square lattice with \( L\times{L} \) nodes. This could for example represent an isolated island, or a closed off city.</li>
<li> At \( t=0 \), all individuals are placed out at random nodes of the lattice.</li>
<li> For each subsequent time step, zombies and humans (walkers) move <a href="https://en.wikipedia.org/wiki/Random_walk" target="_self">randomly</a>. For simplicity, the walkers are assumed to only move in 2 dimensions. This is important: each individual moves in <em>either</em> in the \( x- \) <em>or</em> \( y- \) direction, but not both at the same time (i.e., east, north, west, <em>or</em> south).</li>
<li> After each move, find all nodes where both humans and zombies are present. Every human at such a site will face every zombie in an encounter.</li>
<li> For a given human-zombie interaction, there is a probability \( q \) that the human is infected.</li>

<ul>
    <li> Example: If three humans meet two zombies at a given node, you have to account for six human-zombie pairs. In each encounter, draw a random number between 0 and 1; if it is less than \( q \), the human becomes a zombie (it is possible for multiple zombies to infect the same human).</li>
</ul>

</ul>

<div class="alert alert-block alert-success alert-text-normal"><b>Read this first: Implementation guidelines.</b>
To be able to implement a random walk algorithm in which walkers can have
different properties and/or abilities, you should read through <em>all</em> the
exercises before starting to code. It is important that your program can
handle the different scenarios we want to study.

<p>
Several strategies for how to write your code are suggested in the appendix.
It is recommended that you first read the appendix, even if you choose to
adopt your own strategy.

<p>
Also, in this project it is extra important that you include sufficient documentation to your code.
</div>


<p>
<b>Part 1. (THE MOST DIFFICULT AND COMPREHENSIVE PART)</b>
Write a function and/or class that can be used to conduct a single simulation
of the random walk algorithm. It is important that you add every option
that you will need in later exercises to the function / class!
That is, you should not end up in a situation where you have to copy and paste
large portions of the code repeatedly.

<p>
If you want, you can write your function/class in a separate .py file,
and simply <a href="https://docs.python.org/3/tutorial/modules.html" target="_self">import it</a>
at the top of your Jupyter notebook.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>
The final code should include the following steps:

<ol>
<li> Place walkers randomly on the grid</li>
<li> Move walkers <div id="bp:p4:1"></div></li>
<li> Check if they are at a legal position, move back to previous position if not</li>
<li> Save walker positions</li>
<li> Check nodes for possible human zombie interactions</li>
<li> At certain times, visualize walker positions (good for debugging).</li>
<li> Return to point <a href="#bp:p4:1">bp:p4:1</a></li> 
</ol>

To show walkers at varying time steps can be achieved by e.g. <br />
<code>if i%1000==0: show_walkers()</code>. (Assuming that you have implemented a function called <code>show_walkers()</code>)
</div>


<p>
<b>Part 2.</b>
Let \( L=50 \) and \( q=0.9 \). As before, set \( N=682 \), \( Z(0)=1 \).
Run the (most basic) model repeatedly; at least \( 10-100 \) times.
For each time step, calculate the mean and standard deviation
of the number of the humans and zombies in the population.

<p>
Create a figure showing the expected time development of the two populations.
Make sure to include the computed uncertainty in the plot.

<h1 id="___sec3" class="anchor">Exercise 3: Estimating \( \beta \) and the basic reproduction number </h1>
The original \( SZR \) compartment model was (ignoring incubation time)
$$
\begin{align}
\tag{4}
\frac{\mathrm{d}S(t)}{\mathrm{d}t}&=-\beta(t)\cdot\frac{S(t)Z(t)}{N}\\ 
\tag{5}
\frac{\mathrm{d}Z(t)}{\mathrm{d}t}&=(\beta(t)-\alpha(t))\cdot\frac{S(t)Z(t)}{N}\\ 
\tag{6}
\frac{\mathrm{d}R(t)}{\mathrm{d}t}&=\alpha(t)\frac{S(t)Z(t)}{N}\,,
\end{align}
$$

where \( \beta \) was a constant model input parameter (or two, if using
the exponential decline assumption). However, in the random walk model we
can <em>estimate</em> values for \( \beta \) based on observed changes in the random
walker population. To do this, we combine equation <a href="#mjx-eqn-4">(4)</a>
with a first order approximation of the derivative to yield:
$$
\begin{equation}
\beta\cdot\Delta t \approx -\frac{(S(t)-S(t-\Delta t))N}{S(t)Z(t)},
\tag{7}
\end{equation}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>
The time scale in the random walk model is dependent on the lattice size, i.e.,
how much time does it take for each encounter (depends on the speed of human
and zombies and the size of the simulation domain)
</div>


<p>
<b>Part 1.</b>

<ol>
<li> Run the model once and estimate \( \beta\Delta t \), from which you can estimate \( \beta \) as a function of time (Assume \( \Delta t\simeq \) 1 hour)</li>
<li> Lower the probability \( q \) of a zombie attack leading to infection, and again estimate \( \beta \).</li>
</ol>

In both cases compare the outcome of the random walk simulation with the
analytical solution of the \( SZ \) model (use the mean value of \( \beta \)).

<p>
Comment on the results.

<p>
<b>Part 2.</b>

<p>
Again we will let the probability of being turned into a zombie be \( q=0.9 \).
However, suppose that whenever a human is attacked by a zombie <em>and survives</em>,
the probability of surviving again at a later stage increases:

<ul>
<li> Each time a human survives a zombie encounter, halve the probability of infection, i.e., update <code>q=q*0.5</code> for that person.</li>
<li> What happens now? Plot \( \beta \) as a function of time. How does your prediction fit with the model we used in the project 3, i.e. \( \beta(t)=\beta_0e^{-\lambda t} \)?</li> 
</ul>

<b>Part 3.</b>

<p>
For a slightly more hopeful scenario, assume that each time a human survives a
zombie encounter, two things happen: a) the probability of surviving is
increased as in the last exercise, and b) the human kills the zombie.

<ol>
<li> Estimate \( \alpha \) using a similar approach as for \( \beta \). Plot \( \alpha \) as a function of time.</li>
<li> The basic reproduction number was \( \mathcal{R}_0(t)=\beta(t)/\alpha(t) \). Comment on how the fate of humans and zombies depends on \( \mathcal{R}_0(t) \).</li>
</ol>

<h1 id="___sec4" class="anchor">Exercise 4: Old and young population - who survives? </h1>

<p>
For the remainder of the project, we shall divide the human population into
two groups: young and old. For easy comparison we shall take the number of
people in the two age categories to be the same, that is,
equal to \( (N-1)/2=341 \).

<p>
<b>Part 1.</b>
Young humans and zombies move as before, that is, with equal probability to go
in each of the four directions (except when hitting the outskirts of the grid).
On the other hand, old humans are slower to react: Suppose that the old humans
have the same probability of not moving as they have of moving in one of the
four directions (i.e., 20 \%).

<ul>
<li> Investigate the fate of the humans now, for the case in which humans never learn anything after meeting the zombies, and in the case they kill the zombie</li>
<li> How are the results different from when all humans moved in the same way?</li>
</ul>

<h1 id="___sec5" class="anchor">Exercise 5: Implement your own scenario </h1>

<p>
For the final part of the project, you are going to suggest your own scenario
to explore. You are free to do what ever you like. However, below you will
find examples of possible features to test:

<ul>
<li> Whenever old humans survive a zombie attack, they only have a 30 \% probability of killing the zombie afterwards (the probability of surviving future attacks still goes down by a factor 2)</li>
<li> Add an incubation time, i.e., a certain time interval between when a human first becomes infected, and when the person actually becomes a zombie.</li>
<li> Establish a <em>safe zone</em> in one part of the lattice, i.e., an area in which only humans are allowed to enter.</li>
<li> Combine the previous two features: What happens if humans start exhibiting symptoms only <em>after</em> having entered the safe zone?</li>
<li> Add the option that a zombie will have a higher probability to move in the direction where there are the most humans nearby.</li>
</ul>

Clearly, there are many different choices you may make for each of these
model features, both individually and in combination. Therefore, it is very
important that you state your assumptions carefully, and that you  document
your code accordingly.

<p>
Illustrate your findings in a figure, and discuss how your model scenario compare to the previously investigated cases.

<h1 id="___sec6" class="anchor">Guidelines for project submission </h1>
The assignment is provided both as a PDF, and as a Jupyter notebook.
However, the work done to answer the exercises only has to be handed in as a
notebook, though you can submit an additional PDF if you want.
You should bear the following points in mind when working on the project:

<ul>
<li> Start your notebook by providing a short introduction in which you outline the nature of the problem(s) to be investigated.</li>
<li> End your notebook with a brief summary of what you feel you learned from the project (if anything). Also, if you have any general comments or suggestions for what could be improved in future assignments, this is the place to do it.</li>
<li> All code that you make use of should be present in the notebook, and it should ideally execute without any errors (especially run-time errors). If you are not able to fix everything before the deadline, you should give your best understanding of what is not working, and how you might go about fixing it.</li>
<li> If you use an algorithm that is not fully described in the assignment text, you should try to explain it in your own words. This also applies if the method is described elsewhere in the course material.</li>
<li> In some cases it may suffice to explain your work via comments in the code itself, but other times you might want to include a more elaborate explanation in terms of, e.g., mathematics and/or pseudocode.</li>
<li> In general, it is a good habit to comment your code (though it can be overdone).</li>
<li> When working with approximate solutions to equations, it is always useful to check your results against known exact (analytical) solutions, should they be available.</li>
<li> It is also a good test of a model implementation to study what happens at known 'edge cases'.</li>
<li> Any figures you include should be easily understandable. You should label axes appropriately, and depending on the problem, include other legends etc. Also, you should discuss your figures in the main text.</li>
<li> It is always good if you can reflect a little bit around <em>why</em> you see what you see.</li>
</ul>

<h1 id="app:a" class="anchor">Appendix: Object-oriented programming?</h1>

<p>
When implementing the random walk algorithm, one approach would be to use an
<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_self">object-oriented programming style</a>.
For example,  one could make a <a href="https://docs.python.org/3/tutorial/classes.html" target="_self">class</a>
called <code>Walker</code>, and have subclasses such as <code>Zombie</code>, <code>Human</code>, <code>Infected</code> etc.
However, it can be challenging to decide on the right class hierarchy, as well
as to make the program fast, because it takes more time to access a custom
object than an array.

<p>
We will not pursue this approach further here.

<h1 id="app:b" class="anchor">Appendix: The use of arrays to simulate a random walk</h1>

<p>
An alternative method is to use a set of global arrays to record the state of
the system. This option is more computationally efficient, but it requires
more of you as a programmer; to code without classes, there is a good chance
that your code will be hard to read.
Below are some <em>suggestions</em> for how to proceed with this approach.
It is important to follow some principles when structuring your code:

<ul>
<li> The arrays will be accessed in various functions, and it is therefore important that they have have intuitive variable names.</li>
<li> You should distinguish variables defined outside functions from those that are only used locally within a function. A common convention is to end global variable names with an underscore <code>_</code>.</li>
<li> It is good practice to explicitly declare variables as global if you are going to change them inside a function: put the keyword <code>global</code> in front.</li>
<li> You should do this even for lists/arrays, which <a href="https://towardsdatascience.com/immutable-vs-mutable-data-types-in-python-e8a9a6fcfbdc" target="_self">can be modified in-place</a> without the global keyword. This way you make it absolutely clear to people reading your code that it is going to be treated like a global variable.</li>
<li> Very important: If you need to save, e.g., the positions of all walkers in order to use them at a later stage, you have to use <code>np.copy</code> (see further remarks below).</li>
</ul>

Below is one suggestion for a possible code structure:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">global</span> Walkers_     <span style="color: #408080; font-style: italic"># (x,y) coordinate of each walker at time T</span>
<span style="color: #008000; font-weight: bold">global</span> N_           <span style="color: #408080; font-style: italic"># Total population</span>
<span style="color: #008000; font-weight: bold">global</span> nxy_         <span style="color: #408080; font-style: italic"># Lattice size (a square) nx=ny</span>
</pre></div>
<p>
Here, <code>Walkers</code>  is a 2D array, with a \( (x,y) \) coordinate stored for each walker.
To generate a random position for each walker, we can simply draw one
$x-$coordinate, and one $y-$coordinate:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Walkers_<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randint(nxy_<span style="color: #666666">+1</span>,size<span style="color: #666666">=</span>(N_,<span style="color: #666666">2</span>))
</pre></div>
<p>
Put, e.g., <code>nxy_=5</code>, and <code>N_=10</code>, <code>print(Walkers_)</code> and inspect the result.
The next issue is how to move the walkers. It is important that they move
at <em>random</em> and only <em>one step</em>, in <em>either</em> the \( x- \) <em>or</em> the $y-$direction.
There are many ways to achieve this. One method is to draw a random integer
\( u \) between 1 and 4. If <code>u==1</code> move east, if <code>u==2</code> move north,
if <code>u==3</code> move west, and if <code>u==4</code> move south.
Assume for simplicity that we only have five walkers, and that for each of
them we have randomly chosen the following new steps:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>next_pos<span style="color: #666666">=</span>[[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>],[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>],[<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>]]
</pre></div>
<p>
Then we can simply update the position of the walkers as follows:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Walkers_ <span style="color: #666666">+=</span> next_pos
</pre></div>
<p>
In our case we need to make sure that none of the walkers move outside the
grid. One way of doing this is to store all old (legal) positions
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">global</span> Walkers_Old_ <span style="color: #408080; font-style: italic"># old (x,y) position</span>
Walkers_Old_ <span style="color: #666666">=</span> Walkers_<span style="color: #666666">.</span>copy()
</pre></div>
<p>
Notice the use of <code>copy()</code> here. If you simply put
<code>Walkers_Old_ = Walkers_</code>, it would not work, because arrays are
<a href="https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a" target="_self">mutable</a>
objects in Python. That is, if <code>Walkers_</code> were assigned directly to <code>Walkers_Old</code>,
both variable names would point to the same underlying object in memory.
However, since the arrays contain objects of an immutable type (<code>int</code>),
one way to avoid this problem is to create a shallow copy with <code>copy()</code>.
In yet other applications, a
<a href="https://realpython.com/copying-python-objects/" target="_self"><tt>deepcopy()</tt></a>
operation might be needed.
<!-- same <a href="https://www.tutorialspoint.com/numpy/numpy_copies_and_views.htm" target="_self">reference</a>. -->

<p>
Next, we find the index of all walkers outside the simulation domain, and put
them back to the old position (this is often called a bounce back boundary
condition)
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># idx is an array of all walkers at illegal positions</span>
Walkers_[idx]<span style="color: #666666">=</span>Walkers_Old_[idx]
Walkers_Old_ <span style="color: #666666">=</span> Walkers_<span style="color: #666666">.</span>copy() <span style="color: #408080; font-style: italic"># save the new positions</span>
</pre></div>
<p>
We still have no information about what type (zombie, infected, dead, etc.)
the individual walkers are. Below is a suggestion on how to do this:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">global</span> State_       <span style="color: #408080; font-style: italic"># Human = 0, Zombie = 1, Dead = 2, etc.</span>
HUMAN_  <span style="color: #666666">=</span> <span style="color: #666666">0</span>
ZOMBIE_ <span style="color: #666666">=</span> <span style="color: #666666">1</span>
DEAD_   <span style="color: #666666">=</span> <span style="color: #666666">2</span>

State_<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(N_,dtype<span style="color: #666666">=</span><span style="color: #008000">int</span>) <span style="color: #408080; font-style: italic"># Set all Walkers to Human</span>
State_[<span style="color: #666666">0</span>]<span style="color: #666666">=</span>ZOMBIE_             <span style="color: #408080; font-style: italic"># Set one of them to a Zombie</span>
</pre></div>
<p>
In this way it is easy to add more states, as the simulation is progressing
the <code>State_</code> array will be updated. At any given time we can find the total
number of humans, zombies, dead etc by using <code>np.bincount(State_)</code>,
see <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html" target="_self">documentation</a>.
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>population <span style="color: #666666">=</span> np<span style="color: #666666">.</span>bincount(State_) <span style="color: #408080; font-style: italic"># count number of 0, 1, 2 etc</span>
population[ZOMBIE_] <span style="color: #408080; font-style: italic"># returns number of zombies</span>
population[HUMAN_]  <span style="color: #408080; font-style: italic"># returns number of humans</span>
</pre></div>
<p>
A small warning: the above code does not work when, e.g., the humans disappear
completely. This is because <code>np.bincount</code> counts the number of integers.
If there are no zeros, the number 1 will be stored in <code>population[0]</code>, and
the code will produce an error.
To fix this, you could add an extra <code>if</code>-clause. Alternatively, you could
use <code>np.count_nonzero instead</code>, e.g.:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>num_humans <span style="color: #666666">=</span> np<span style="color: #666666">.</span>count_nonzero(State_<span style="color: #666666">==</span>HUMAN_)
num_zombies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>count_nonzero(State_<span style="color: #666666">==</span>ZOMBIE_)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Important note!</b>
During Monte Carlo simulation, you have to run the algorithm from
start to finish many times. If you opt for the method outlined
in this appendix, you will therefore have to include the whole
algorithm inside some kind of function or loop, which are to be
evaluated repeatedly.
</div>


<h1 id="app:c" class="anchor">Appendix: The combined use of classes and arrays</h1>

<p>
Yet another approach is to use a (single) class instead of a function to
keep track of the state of a given simulation run. For example, the current
state of the system can be stored in a set of class instance variables,
while the integers flags denoting the status of a walker (human, zombie, etc.)
can be class variables. The following code exemplifies the beginning of one
such implementation:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">ZombieSimulator</span>:
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Class used to model the invasion of zombies in a closed off</span>
<span style="color: #BA2121; font-style: italic">    area with a 2-dimensional random walk.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Class variables:</span>
    HUMAN_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    ZOMBIE_ <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    KILLED_ZOMBIE_ <span style="color: #666666">=</span> <span style="color: #666666">2</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, num_humans0, num_zombies0, <span style="color: #666666">*</span>, L<span style="color: #666666">=100</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        Constructor used to initialize the model.</span>

<span style="color: #BA2121; font-style: italic">        :param num_humans0: Number of humans at t=0.</span>
<span style="color: #BA2121; font-style: italic">        :param num_zombies0: Number of zombies at t=0.</span>
<span style="color: #BA2121; font-style: italic">        :param L: Number of lattice nodes in each dimension.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>

        <span style="color: #008000">self</span><span style="color: #666666">.</span>L <span style="color: #666666">=</span> L
        <span style="color: #008000">self</span><span style="color: #666666">.</span>initial_no_humans <span style="color: #666666">=</span> num_humans0
        <span style="color: #008000">self</span><span style="color: #666666">.</span>initial_no_zombies <span style="color: #666666">=</span> num_zombies0
        <span style="color: #008000">self</span><span style="color: #666666">.</span>total_population <span style="color: #666666">=</span> num_humans0 <span style="color: #666666">+</span> num_zombies0

        <span style="color: #408080; font-style: italic"># Various model options (to do: add more options here!!)</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>infection_probability <span style="color: #666666">=</span> <span style="color: #666666">0.9</span>

        <span style="color: #408080; font-style: italic"># Current simulation state:</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>current_time_step <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>pop_status <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">self</span><span style="color: #666666">.</span>total_population, dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;int&#39;</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>pos_x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">self</span><span style="color: #666666">.</span>total_population, dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;int&#39;</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>pos_y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">self</span><span style="color: #666666">.</span>total_population, dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;int&#39;</span>)

        <span style="color: #408080; font-style: italic"># Prepare for simulation:</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>reset_initial_population_distribution()

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">reset_initial_population_distribution</span>(<span style="color: #008000">self</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        Reset model to time zero, including the initial random</span>
<span style="color: #BA2121; font-style: italic">        placement of humans and zombies on the lattice.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
        L <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>L

        <span style="color: #408080; font-style: italic"># TO DO:</span>
        <span style="color: #408080; font-style: italic"># Select initial, random locations for humans and zombies (!)</span>

        <span style="color: #408080; font-style: italic"># Since locations were chosen randomly, we can let the first</span>
        <span style="color: #408080; font-style: italic"># ones in the array be the zombies:</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>pop_status<span style="color: #666666">.</span>fill(ZombieSimulator<span style="color: #666666">.</span>HUMAN_)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>pop_status[:<span style="color: #008000">self</span><span style="color: #666666">.</span>initial_no_zombies]<span style="color: #666666">.</span>fill(ZombieSimulator<span style="color: #666666">.</span>ZOMBIE_)

        <span style="color: #408080; font-style: italic"># Reset time counter:</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>current_time <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_population_distribution</span>(<span style="color: #008000">self</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        Plot the spatial distribution of humans and zombies</span>
<span style="color: #BA2121; font-style: italic">        at the current moment in time.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">pass</span> <span style="color: #408080; font-style: italic"># TO DO: implement code here (!)</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">simulate_random_walk</span>(<span style="color: #008000">self</span>, no_steps, <span style="color: #666666">*</span>, print_steps<span style="color: #666666">=</span><span style="color: #008000">None</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        Perform a single random walk simulation from start to finish.</span>

<span style="color: #BA2121; font-style: italic">        :param no_steps: Number of time steps to take.</span>
<span style="color: #BA2121; font-style: italic">        :param print_steps: If not None, a list of time steps at</span>
<span style="color: #BA2121; font-style: italic">                            which to plot the spatial population</span>
<span style="color: #BA2121; font-style: italic">                            distribution.</span>
<span style="color: #BA2121; font-style: italic">        :return: Dictionary containing the time steps, and the</span>
<span style="color: #BA2121; font-style: italic">                 corresponding solutions (number of humans,</span>
<span style="color: #BA2121; font-style: italic">                 zombies, etc.)</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>

        <span style="color: #008000">self</span><span style="color: #666666">.</span>reset_initial_population_distribution()

        <span style="color: #408080; font-style: italic"># Allocate arrays in which to store data for the current</span>
        <span style="color: #408080; font-style: italic"># simulation run:</span>
        times <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(no_steps<span style="color: #666666">+1</span>)
        number_of_humans <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(times)
        number_of_zombies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(times)
        number_of_killed_zombies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(times)

        number_of_humans[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>initial_no_humans
        number_of_zombies[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>initial_no_zombies

        <span style="color: #408080; font-style: italic"># Time loop:</span>
        <span style="color: #008000; font-weight: bold">for</span> i, curr_t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(times):

            <span style="color: #008000">self</span><span style="color: #666666">.</span>current_time <span style="color: #666666">=</span> curr_t
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>current_time <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
                <span style="color: #408080; font-style: italic"># TO DO:</span>
                <span style="color: #408080; font-style: italic"># Perform random walk, and check for collisions.</span>
                <span style="color: #408080; font-style: italic"># Store no. of humans, zombies, etc. at current step.</span>
                <span style="color: #008000; font-weight: bold">pass</span>

            <span style="color: #408080; font-style: italic"># Visualize where the humans and zombies are on the grid?</span>
            <span style="color: #008000; font-weight: bold">if</span> print_steps <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> curr_t <span style="color: #AA22FF; font-weight: bold">in</span> print_steps:
                <span style="color: #008000">self</span><span style="color: #666666">.</span>plot_population_distribution()

        solution_dict <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;t&#39;</span>: times,
                         <span style="color: #BA2121">&#39;S&#39;</span>: number_of_humans,
                         <span style="color: #BA2121">&#39;Z&#39;</span>: number_of_zombies,
                         <span style="color: #BA2121">&#39;R&#39;</span>: number_of_killed_zombies}
        <span style="color: #008000; font-weight: bold">return</span> solution_dict
</pre></div>
<p>
Of course, the above code only contains the bare bones of the full
implementation. To program the interesting parts of the algorithm, you
can use many of the ideas that were outlined in  <a href="#app:a">Appendix: Object-oriented programming?</a>.

<p>
An example showing how you can utilize the above class is also included:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>N <span style="color: #666666">=</span> <span style="color: #666666">683</span>
lattice_size <span style="color: #666666">=</span> <span style="color: #666666">10</span>
simulator <span style="color: #666666">=</span> ZombieSimulator(N<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, L<span style="color: #666666">=</span>lattice_size)

no_time_steps <span style="color: #666666">=</span> <span style="color: #666666">200</span>
no_simulations <span style="color: #666666">=</span> <span style="color: #666666">100</span>

sum_of_values_S_ <span style="color: #666666">=</span> <span style="color: #008000">None</span>
sum_of_squares_S_ <span style="color: #666666">=</span> <span style="color: #008000">None</span>
sum_of_values_Z_ <span style="color: #666666">=</span> <span style="color: #008000">None</span>
sum_of_squares_Z_ <span style="color: #666666">=</span> <span style="color: #008000">None</span>

<span style="color: #008000; font-weight: bold">for</span> i_sim <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(no_simulations):

    sol <span style="color: #666666">=</span> simulator<span style="color: #666666">.</span>simulate_random_walk(no_time_steps)
    t_step <span style="color: #666666">=</span> sol[<span style="color: #BA2121">&#39;t&#39;</span>]  <span style="color: #408080; font-style: italic"># note: this is the same for all runs</span>
    S_i <span style="color: #666666">=</span> sol[<span style="color: #BA2121">&#39;S&#39;</span>]
    Z_i <span style="color: #666666">=</span> sol[<span style="color: #BA2121">&#39;Z&#39;</span>]

    <span style="color: #008000; font-weight: bold">if</span> sum_of_values_S_ <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000">None</span>:
        sum_of_values_S_ <span style="color: #666666">=</span> S_i
        sum_of_values_Z_ <span style="color: #666666">=</span> Z_i
        sum_of_squares_S_ <span style="color: #666666">=</span> S_i<span style="color: #666666">**2</span>
        sum_of_squares_Z_ <span style="color: #666666">=</span> Z_i<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        sum_of_values_S_ <span style="color: #666666">+=</span> S_i
        sum_of_values_Z_ <span style="color: #666666">+=</span> Z_i
        sum_of_squares_S_ <span style="color: #666666">+=</span> S_i<span style="color: #666666">**2</span>
        sum_of_squares_Z_ <span style="color: #666666">+=</span> Z_i<span style="color: #666666">**2</span>

<span style="color: #408080; font-style: italic"># Compute mean and standard deviation:</span>
S_mean_ <span style="color: #666666">=</span> sum_of_values_S_<span style="color: #666666">/</span>no_simulations
Z_mean_ <span style="color: #666666">=</span> sum_of_values_Z_<span style="color: #666666">/</span>no_simulations
S_stdev_ <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(sum_of_squares_S_<span style="color: #666666">/</span>no_simulations<span style="color: #666666">-</span>S_mean_<span style="color: #666666">**2</span>)
Z_stdev_ <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(sum_of_squares_Z_<span style="color: #666666">/</span>no_simulations<span style="color: #666666">-</span>Z_mean_<span style="color: #666666">**2</span>)

<span style="color: #408080; font-style: italic"># to do: plot results etc..</span>
</pre></div>

<h1 id="___sec10" class="anchor">Bibliography </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="althaus2014"></div> <b>C. L. Althaus</b>. 
    Estimating the Reproduction Number of Ebola Virus (EBOV) During the 2014 Outbreak in West Africa,
    <em>PLoS currents</em>,
    6,
    2014.</li>
 <li> <div id="pearson1905problem"></div> <b>K. Pearson</b>. 
    The Problem of the Random Walk,
    <em>Nature</em>,
    72(1867),
    pp. 342,
    1905.</li>
 <li> <div id="codling2008random"></div> <b>E. A. Codling, M. J. Plank and S. Benhamou</b>. 
    Random Walk Models in Biology,
    <em>Journal of the Royal society interface</em>,
    5(25),
    pp. 813-834,
    2008.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">

  <li class="previous">
    <a href="._project4-readable000.html">&larr; Prev</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

