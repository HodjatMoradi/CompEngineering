
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="1.0">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Ordinary differential equations &#8212; Modeling and Computational Engineering 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="References" href="._book005.html" />
    <link rel="prev" title="Numerical integration" href="._book003.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="ordinary-differential-equations">
<span id="ch-ode"></span><h1>Ordinary differential equations<a class="headerlink" href="#ordinary-differential-equations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>Ordinary Differential Equations<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Physical systems evolves in space and time, and very often they are described by a ordinary differential equations (ODE) and/or
partial differential equations (PDE). The difference between an ODE and a PDE is that an ODE only describes
the changes in one spatial dimension <em>or</em> time, whereas a PDE describes a system that evolves in the <span class="math notranslate nohighlight">\(x-\)</span>, <span class="math notranslate nohighlight">\(y-\)</span>, <span class="math notranslate nohighlight">\(z-\)</span> dimension
and/or in time. In the following we will spend a significant
amount of time to explore one of the simplest algorithm, Eulers method.
Sometimes this is exactly the algorithm you would like to use, but with very
little extra effort much more sophisticated algorithms can easily be implemented, such as the Runge-Kutta fourth order method.
However, all these algorithms, will at some point run into the same
kind of troubles if used reckless. Thus we will use the Eulers method as a playground,
investigate when the algorithm run into trouble and
suggests ways to fix it, these approaches can easily be extended to the higher order methods. Most of the other algorithms boils down to the same idea of extrapolating
a function using derivatives multiplied with a small step size.</p>
</div>
<div class="section" id="a-simple-model-for-fluid-flow">
<h2>A Simple Model for Fluid Flow<a class="headerlink" href="#a-simple-model-for-fluid-flow" title="Permalink to this headline">¶</a></h2>
<p>Let us consider a simple example from chemical engineering, a continuous stirred tank reactor (CSTR), see figure <a class="reference internal" href="#fig-ode-cstr"><span class="std std-ref">A continuous stirred tank model, , and </span></a>.
The flow is incompressible (<span class="math notranslate nohighlight">\(q_\text{out}=q_\text{in}\)</span>), a fluid is entering
on the top and exiting at the bottom, the tank has a fixed volume <span class="math notranslate nohighlight">\(V\)</span>. Assume that the tank is filled with saltwater, and that freshwater is pumped into it, how much time does it
take before <span class="math notranslate nohighlight">\(90\%\)</span> of the saltwater is replaced with freshwater? The tank is <em>well mixed</em>, illustrated with the propeller, this means that at every time the
concentration is uniform in the tank, i.e. that <span class="math notranslate nohighlight">\(C(t)=C_\text{out}(t)\)</span>.</p>
<div class="figure" id="id3">
<span id="fig-ode-cstr"></span><a class="reference internal image-reference" href="_images/cstr.png"><img alt="_images/cstr.png" src="_images/cstr.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">A continuous stirred tank model, <span class="math notranslate nohighlight">\(C(t)=C_\text{out}(t)\)</span>, and <span class="math notranslate nohighlight">\(q_\text{out}=q_\text{in}\)</span></span></p>
</div>
<p>The concentration <span class="math notranslate nohighlight">\(C\)</span> is measured in gram of salt per liter water, and the flow rate <span class="math notranslate nohighlight">\(q\)</span> is liter of water per day. The model for the salt balance in this system can be described in words by:</p>
<div class="math notranslate nohighlight">
\[[\text{accumulation of salt}] = [\text{salt into the system}] - [\text{salt out of the system}]\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-mbal">
\[\tag{76}
+ [\text{generation of salt}].\]</div>
<p>In our case there are no generation of salt within the system so this term is zero. The flow of salt into the system during a time <span class="math notranslate nohighlight">\(\Delta t\)</span> is:
<span class="math notranslate nohighlight">\(q_\text{in}(t)\cdot C_\text{in}(t)\cdot \Delta t=q(t)\cdot C_\text{in}(t)\cdot \Delta t\)</span>,
the flow of salt out of the system is: <span class="math notranslate nohighlight">\(q_\text{out}(t)\cdot C_\text{out}(t)\cdot \Delta t=q(t)\cdot C(t)\cdot \Delta t\)</span>, and the accumulation during a time step is:
<span class="math notranslate nohighlight">\(C(t+\Delta t)\cdot V - C(t)\cdot V\)</span>, hence:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr1">
\[\tag{77}
C(t+\Delta t)\cdot V - C(t)\cdot V = q(t)\cdot C_\text{in}(t)\cdot \Delta t - q(t)\cdot C(t)\cdot \Delta t.\]</div>
<p>Note that it is not a priori apparent, which time the concentrations and flow rates on the right hand side should be evaluated at,
we could have chosen to evaluate them at <span class="math notranslate nohighlight">\(t+\Delta t\)</span>, or at any time <span class="math notranslate nohighlight">\(t\in [t,t+\Delta t]\)</span>. We will return to this point later in this chapter. Dividing by <span class="math notranslate nohighlight">\(\Delta t\)</span>, and taking the limit
<span class="math notranslate nohighlight">\(\Delta t\to 0\)</span>, we can write equation <a class="reference internal" href="#eq-eq-ode-cstr1"><span class="std std-ref">(77)</span></a> as:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2">
\[\tag{78}
V\frac{dC(t)}{dt} = q(t)\left[C_\text{in}(t) - C(t)\right].\]</div>
<p>Seawater contains about 35 gram salt/liter fluid, if we assume that the fresh water contains no salt, we have the boundary conditions
<span class="math notranslate nohighlight">\(C_\text{in}(t)=0\)</span>, $C(0)=$35gram/l. The equation <a class="reference internal" href="#eq-eq-ode-cstr2"><span class="std std-ref">(78)</span></a> the reduces to:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3">
\[\tag{79}
V\frac{dC(t)}{dt} = -qC(t),\]</div>
<p>this equation can easily be solved, by dividing by <span class="math notranslate nohighlight">\(C\)</span>, multiplying by <span class="math notranslate nohighlight">\(dt\)</span> and integrating:</p>
<div class="math notranslate nohighlight">
\[V\int_{C_0}^C\frac{dC}{C} = -q\int_0^tdt,\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-sol">
\[\tag{80}
C(t)=C_0e^{-t/\tau},\text{ where } \tau\equiv \frac{V}{q}.\]</div>
<p>This equation can be inverted to give <span class="math notranslate nohighlight">\(t=-\tau\ln[C(t)/C]\)</span>. If we assume that the volume of the tank is 1m$^3$=1000liters,
and that the flow rate is 1 liter/min, we find that $tau$=1000min=0.69days and that it takes about $-0.69ln0.9simeq1.6$days to reduce the concentration
by 90$%$ to 3.5 gram/liter.</p>
<div class="admonition-the-cstr admonition">
<p class="first admonition-title">The CSTR</p>
<p class="last">You might think that the CSTR is a very simple model, and it is, but this type of model is the basic building blocks in chemical engineering.
By putting CSTR tanks in series and/or connecting them with pipes, the efficiency of manufacturing various type of chemicals
can be investigated. Although the CSTR is an idealized model for the part of a chemical factory, it is actually a <em>very good</em> model
for fluid flow in a porous media. By connecting CSTR tanks in series, one can model how chemical tracers propagate in the subsurface.
The physical reason for this is that dispersion in porous media will play the role of the propellers and mix the concentration
uniformly.</p>
</div>
</div>
<div class="section" id="eulers-method">
<h2>Eulers Method<a class="headerlink" href="#eulers-method" title="Permalink to this headline">¶</a></h2>
<p>If the system gets slightly more complicated, e.g several tanks in series with a varying flow rate or if salt was generated in the tank, there is a
good chance that we have to solve the equations numerically to obtain a solution.
Actually, we have already developed a numerical algorithm to solve equation <a class="reference internal" href="#eq-eq-ode-cstr2"><span class="std std-ref">(78)</span></a>,
before we arrived at equation <a class="reference internal" href="#eq-eq-ode-cstr2"><span class="std std-ref">(78)</span></a> in equation <a class="reference internal" href="#eq-eq-ode-cstr1"><span class="std std-ref">(77)</span></a>. This is a special case of Eulers method, which is basically to
replace the derivative in equation <a class="reference internal" href="#eq-eq-ode-cstr2"><span class="std std-ref">(78)</span></a>, with <span class="math notranslate nohighlight">\((C(t+\Delta t)-C(t))/\Delta t\)</span>. By rewriting equation <a class="reference internal" href="#eq-eq-ode-cstr1"><span class="std std-ref">(77)</span></a>, so that we
keep everything related to the new time step, <span class="math notranslate nohighlight">\(t+\Delta t\)</span>, on one side, we get:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-eu0">
\[\tag{81}
VC(t+\Delta t) = VC(t) + qC_\text{in}(t) - qC(t),\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-eu1">
\[\tag{82}
C(t+\Delta t) = C(t) + \frac{\Delta t}{\tau}\left[C_\text{in}(t) - C(t)\right]\,\]</div>
<p>we introduce the short hand notation: <span class="math notranslate nohighlight">\(C(t)=C_n\)</span>, and <span class="math notranslate nohighlight">\(C(t+\Delta t)=C_{n+1}\)</span>, hence the algorithm can be written more compact as:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-eu2">
\[\tag{83}
C_{n+1} = \left(1-\frac{\Delta t}{\tau}\right)C_n + \frac{\Delta t}{\tau}C_{\text{in},n}\,\]</div>
<p>In the script below, we have implemented equation <a class="reference internal" href="#eq-eq-ode-eu2"><span class="std std-ref">(83)</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">analytical</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">euler_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span> <span class="n">tau_inv</span><span class="p">,</span><span class="n">dt</span><span class="p">):</span>
    <span class="n">fact</span><span class="o">=</span><span class="n">dt</span><span class="o">*</span><span class="n">tau_inv</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">fact</span><span class="p">)</span><span class="o">*</span><span class="n">c_old</span><span class="o">+</span><span class="n">fact</span><span class="o">*</span><span class="n">c_in</span>

<span class="k">def</span> <span class="nf">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">vol</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">dt</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">tau_inv</span> <span class="o">=</span> <span class="n">q</span><span class="o">/</span><span class="n">vol</span>
    <span class="n">c_in</span>    <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into tank</span>
    <span class="n">c_old</span>   <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="n">c_new</span> <span class="o">=</span> <span class="n">euler_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">tau_inv</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_new</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">dt</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">f</span>
</pre></div>
</div>
<div class="figure" id="id4">
<span id="fig-ode-euler"></span><a class="reference internal image-reference" href="_images/euler.png"><img alt="_images/euler.png" src="_images/euler.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The concentration in the tank for different step size <span class="math notranslate nohighlight">\(\Delta t\)</span></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-euler"><span class="std std-ref">The concentration in the tank for different step size </span></a> the result of the implementation is shown for different values of <span class="math notranslate nohighlight">\(\Delta t\)</span>
Clearly we see that the results are dependent on the step size, as the step increases the numerical solution deviates from the analytical solution. At some point the
numerical algorithm fails completely, and produces results that have no meaning.</p>
<div class="section" id="error-analysis-eulers-method">
<h3>Error Analysis - Eulers Method<a class="headerlink" href="#error-analysis-eulers-method" title="Permalink to this headline">¶</a></h3>
<p>There are two obvious questions:
1. When does the algorithm produce unphysical results?</p>
<ol class="arabic simple" start="2">
<li>What is an appropriate step size?</li>
</ol>
<p>Let us consider the first question, clearly when the concentrations gets negative the solution is unphysical. From equation <a class="reference internal" href="#eq-eq-ode-eu2"><span class="std std-ref">(83)</span></a>,
we see that when <span class="math notranslate nohighlight">\(\Delta t/\tau &gt; 1\)</span>, the concentration
become negative. For this specific case (the CSTR), there is a clear physical interpretation of this condition. Inserting <span class="math notranslate nohighlight">\(\tau=V/q\)</span>, we can rewrite
the condition <span class="math notranslate nohighlight">\(\Delta t/\tau &lt;1\)</span> as <span class="math notranslate nohighlight">\(q\Delta t &lt; V\)</span>. The volume into the tank during one time step is: <span class="math notranslate nohighlight">\(q\Delta t\)</span>, which means that
whenever we <em>flush more than one tank volume through the tank during one time step, the algorithm fails</em>.
When this happens the new concentration in the tank cannot be predicted from the old one. This makes sense, because we could have switched to a
new solution (e.g. seawater) during that time step, then the new solution does not have any relation to the old solution.</p>
<p>The second question, &quot;what is an appropriate step size?&quot;,  is a bit more difficult to answer.
One strategy could be to simply use the results from chapter [Taylor], where we showed that the truncation error had a minimum value
with a step size of <span class="math notranslate nohighlight">\(10^{-8}\)</span>  (when using a first order Taylor approximation).
How does the value <span class="math notranslate nohighlight">\(10^{-8}\)</span> relate to the step sizes in minutes used in our Euler implementation?
In order to see the connection, we need to rewrite equation <a class="reference internal" href="#eq-eq-ode-cstr2"><span class="std std-ref">(78)</span></a> in a dimensionless form,
by making the following substitution:</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(t\to t/\tau\)</span>:</div></blockquote>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2dim">
\[\tag{84}
\frac{dC(\tau)}{d\tau} = \left[C_\text{in}(\tau) - C(\tau)\right].\]</div>
<p>As we found earlier $tau = 1000$min, thus a step size of e.g. 1 min would correspond to a dimensionless time step of
$Delta tto$1min/1000min$=10^{-3}$. This number can be directly compared to the value <span class="math notranslate nohighlight">\(10^{-8}\)</span>, which is the lowest value we can
choose without getting into trouble with round off errors on the machine.</p>
<div class="admonition-dimensionless-variables admonition">
<p class="first admonition-title">Dimensionless variables</p>
<p>It is a  good idea (necessary) to formulate our equations in terms of dimensionless variables.
The algorithms we develop can then be used in the same form regardless of changes in the system size and flow rates.
Thus we do not need to rewrite the algorithm each time the physical system changes. This also means that if you use
an algorithm developed by someone else (e.g. in Matlab or Python), you should always formulate the ODE system in dimensionless
form before using the algorithm.</p>
<p class="last">A second reason is that from a pure modeling point of view, dimensionless variables is a way of getting some
understanding of what kind of combination of the physical parameters that describes the behavior of the system.
For the case of the CSTR, there is a time scale <span class="math notranslate nohighlight">\(\tau=V/q\)</span>, which
is an intrinsic measure of time in the system. No matter what the flow rate through the tank or the volume of the tank is,
it will always take  0.1$tau$ before
the concentration in the tank is reduced by 90%.</p>
</div>
<p>As already mentioned a step size of <span class="math notranslate nohighlight">\(10^{-8}\)</span>, is probably the smallest we can choose with respect to round off errors,
but it is smaller than necessary and would lead to large simulation times.
If it takes 1 second to run the simulation with a step size of <span class="math notranslate nohighlight">\(10^{-3}\)</span>, it would take <span class="math notranslate nohighlight">\(10^5\)</span> seconds or 1 day
with a step size of <span class="math notranslate nohighlight">\(10^{-8}\)</span>.
To continue the error analyses, we write our ODE for a general system as:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ode">
\[\tag{85}
\frac{dy}{dt}=f(y,t),\]</div>
<p>or in discrete form:</p>
<div class="math notranslate nohighlight">
\[\frac{y_{n+1}-y_n}{h}-\frac{h}{2}y^{\prime\prime}(\eta_n)=f(y,t).\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto56">
\[\tag{86}
y_{n+1}=y_n+hf(y,t)+\frac{h^2}{2}y^{\prime\prime}(\eta_n).\]</div>
<p><span class="math notranslate nohighlight">\(h\)</span> is now the (dimensionless) step size, equal to <span class="math notranslate nohighlight">\(\Delta t\)</span> if the derivative is with respect to <span class="math notranslate nohighlight">\(t\)</span> or <span class="math notranslate nohighlight">\(\Delta x\)</span> if the derivative is respect to <span class="math notranslate nohighlight">\(x\)</span> etc. Note that we
have also included the error term related to the numerical derivative, <span class="math notranslate nohighlight">\(\eta_n\in[t_n,t_n+h]\)</span>. At each step we get an error term,
and the distance between the true solution and our estimate, the <em>local error</em>, after <span class="math notranslate nohighlight">\(N\)</span> steps is:</p>
<div class="math notranslate nohighlight">
\[\epsilon=\sum_{n=0}^{N-1}\frac{h^2}{2}y^{\prime\prime}(\eta_n)=\frac{h^2}{2}\sum_{n=0}^{N-1}f^\prime(y_n,\eta_n)\simeq\frac{h}{2}\int_{t_0}^{t_f}f^\prime(y,\eta)d\eta\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-eu3">
\[\tag{87}
=\frac{h}{2}\left[f(y(t_f),t_f)-f(y(t_0),t_0)\right].\]</div>
<p>Note that when we replace the sum with an integral in the equation above, this is only correct if the step size is not too large.
From equation <a class="reference internal" href="#eq-eq-ode-eu3"><span class="std std-ref">(87)</span></a>
we see that even if the error term on the numerical derivative is <span class="math notranslate nohighlight">\(h^2\)</span>, the local error is proportional to <span class="math notranslate nohighlight">\(h\)</span>
(one order lower). This is because we accumulate errors for each step.</p>
<p>In the following we specialize to the CSTR, to see if we can gain some additional insight. First we change variables in
equation <a class="reference internal" href="#eq-eq-ode-cstr3"><span class="std std-ref">(79)</span></a>: <span class="math notranslate nohighlight">\(y=C(t)/C_0\)</span>, and <span class="math notranslate nohighlight">\(x=t/\tau\)</span>, hence:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-simple">
\[\tag{88}
\frac{dy}{dx}=-y.\]</div>
<p>The solution to this equation is <span class="math notranslate nohighlight">\(y(x)=e^{-x}\)</span>, substituting back for the new variables <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(x\)</span>, we reproduce the result in equation <a class="reference internal" href="#eq-eq-ode-sol"><span class="std std-ref">(80)</span></a>.
The local error, equation <a class="reference internal" href="#eq-eq-ode-eu3"><span class="std std-ref">(87)</span></a>, reduces to:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-eu4">
\[\tag{89}
\epsilon=\frac{h}{2}\left[-y(x_f)+y(x_0)\right]=\frac{h}{2}\left[1-e^{-x_f}\right],\]</div>
<p>we have assumed that <span class="math notranslate nohighlight">\(x_0=t_0/\tau=0\)</span>. This gives the estimated local error at time <span class="math notranslate nohighlight">\(x_f\)</span>. For <span class="math notranslate nohighlight">\(x_f=0\)</span>, the
numerical error is zero, this makes sense because at <span class="math notranslate nohighlight">\(x=0\)</span> we know the exact solution because of the initial conditions. When we move further away from the initial conditions, the
numerical error increases, but equation <a class="reference internal" href="#eq-eq-ode-eu4"><span class="std std-ref">(89)</span></a> ensures us that as long as the step size is low enough we can get as
close as possible to the true solution, since the error scales as <span class="math notranslate nohighlight">\(h\)</span> (at some point we might run into trouble with round off error in the computer).</p>
<p>Can we prove directly that we get the analytical result? In this
case it is fairly simple, if we use Eulers method on equation <a class="reference internal" href="#eq-eq-ode-simple"><span class="std std-ref">(88)</span></a>, we get:</p>
<div class="math notranslate nohighlight">
\[\frac{y_{n+1}-y_n}{h}=-y_nf.\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto57">
\[\tag{90}
y_{n+1}=(1-h)y_n,\]</div>
<p>or alternatively:</p>
<div class="math notranslate nohighlight">
\[y_1=(1-h)y_0,\nonumber\]</div>
<div class="math notranslate nohighlight">
\[y_2=(1-h)y_1=(1-h)^2y_0,\nonumber\]</div>
<div class="math notranslate nohighlight">
\[\vdots\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto58">
\[\tag{91}
y_{N+1}=(1-h)^{N}y_0=(1-h)^{x_f/h}y_0.\]</div>
<p>In the last equation, we have used the the fact the number of steps, <span class="math notranslate nohighlight">\(N\)</span>, is equal to the simulation time divided by the step size, hence: <span class="math notranslate nohighlight">\(N=x_f/h\)</span>. From calculus,
the equation above is one of the well known limits for the exponential function: <span class="math notranslate nohighlight">\(\lim_{x\to\infty}(1+k/x)^{mx}=e^{mk}\)</span>, hence:</p>
<div class="math notranslate nohighlight" id="eq-auto59">
\[\tag{92}
y_n=(1-h)^{x_f/h}y_0\to e^{-x_f},\]</div>
<p>when <span class="math notranslate nohighlight">\(h\to0\)</span>. Below is an implementation of the Euler algorithm in this simple case, we also estimate the local error, and global error after <span class="math notranslate nohighlight">\(N\)</span> steps.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">euler</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="n">t</span><span class="o">=</span><span class="p">[];</span><span class="n">f</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span><span class="n">fi</span><span class="o">=</span><span class="mf">1.</span>
    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span><span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
    <span class="n">global_err</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span><span class="o">&lt;=</span> <span class="n">tf</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">+=</span><span class="n">h</span>
        <span class="n">fi</span><span class="o">=</span><span class="n">fi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">)</span>
        <span class="n">global_err</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">-</span><span class="n">fi</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span><span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;error= &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">-</span><span class="n">fi</span><span class="p">,</span><span class="s2">&quot; est.err=&quot;</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ti</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;global error=&quot;</span><span class="p">,</span><span class="n">global_err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">f</span>

<span class="n">t</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="n">euler</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1e-5</span><span class="p">)</span>
</pre></div>
</div>
<p>By changing the step size <span class="math notranslate nohighlight">\(h\)</span>, you can easily verify that the local error systematically increases or decreases proportional to <span class="math notranslate nohighlight">\(h\)</span>.
Something curious happens with the global error when the
step size is changed, it does not change very much. The global error involves a second sum over the local error for each step,
which can be approximated as a second integration in equation <a class="reference internal" href="#eq-eq-ode-eu4"><span class="std std-ref">(89)</span></a>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-eu5">
\[\tag{93}
\epsilon_\text{global}=\frac{1}{2}\int_{0}^{x_f}\left[-y(x)+y(0)\right]dx=\frac{1}{2}\left[x_f+e^{-x_f}-1\right].\]</div>
<p>Note that the global error does not go to zero when the step size decreases, which can easily be verified by changing the step size. This is strange, but can be understood
by the following argument: when the step size decreases the local error scales as <span class="math notranslate nohighlight">\(\sim h\)</span>, but the number of steps scales as <span class="math notranslate nohighlight">\(1/h\)</span>, so the global error must scale as <span class="math notranslate nohighlight">\(h\times 1/h\)</span>
or some constant value. Usually it is much easier to control the local error than the global error, this should be kept in mind if you ever encounter a problem where it is
important control the global error. For the higher order methods that we will discuss later in this chapter, the global error will go to zero when <span class="math notranslate nohighlight">\(h\)</span> decreases.</p>
<p>The answer to our original question, ''What is an appropriate step size?'', will depend on what you want to achieve in terms of local or global error.
In most practical situations you would
specify a local error that is acceptable for the problem under investigation and then choose a step size where the local error always is lower than this value. In the
next subsection we will investigate how to achieve this in practice.</p>
</div>
<div class="section" id="adaptive-step-size-eulers-method">
<h3>Adaptive step size - Eulers Method<a class="headerlink" href="#adaptive-step-size-eulers-method" title="Permalink to this headline">¶</a></h3>
<p>We want to be sure that we use a step size that achieves a certain accuracy in our numerical solution, but at
the same time that we do not waste simulation time using a too low step size. The following approach is similar to the one we derived for the Romberg integration, and
a special case of what is known as Richardson Extrapolation. The method is easily extended to higher order methods.</p>
<p>We know that Eulers algorithm is accurate to second order. Our estimate of the new value, <span class="math notranslate nohighlight">\(y_1^*\)</span>
(where we have used a$,{}^*$ to indicate that we have used a step size of size <span class="math notranslate nohighlight">\(h\)</span>), should then be related to the true solution <span class="math notranslate nohighlight">\(y(t_1)\)</span> in the following way:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-aeb0">
\[\tag{94}
y^*_1=y(t_1)+ch^2.\]</div>
<p>The constant <span class="math notranslate nohighlight">\(c\)</span> is unknown, but it can be found by taking two smaller steps of size <span class="math notranslate nohighlight">\(h/2\)</span>. If the steps are not too large, our new estimate
of the value <span class="math notranslate nohighlight">\(y_1\)</span> will be related to the true solution as:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-aeb1">
\[\tag{95}
y_1=y(t_1)+2c\left(\frac{h}{2}\right)^2.\]</div>
<p>The factor 2 in front of <span class="math notranslate nohighlight">\(c\)</span> is because we now need to take two steps, and we accumulate a total error of <span class="math notranslate nohighlight">\(2c(h/2)^2=ch^2/2\)</span>. It might not be completely
obvious that the constant <span class="math notranslate nohighlight">\(c\)</span> should be the same in equation <a class="reference internal" href="#eq-eq-ode-aeb0"><span class="std std-ref">(94)</span></a> and <a class="reference internal" href="#eq-eq-ode-aeb1"><span class="std std-ref">(95)</span></a>. If you are not convinced, there is an exercise at the end
of the chapter.
We define:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae5">
\[\tag{96}
\Delta\equiv y^*_1-y_1=c\frac{h^2}{2}.\]</div>
<p>The truncation error in equation <a class="reference internal" href="#eq-eq-ode-aeb1"><span class="std std-ref">(95)</span></a> is:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae5b">
\[\tag{97}
\epsilon=y(t_1)-y_1=2c\left(\frac{h}{2}\right)^2=\Delta.\]</div>
<p>Now we have everything we need: We want the local error to be smaller than some predefined
tolerance, <span class="math notranslate nohighlight">\(\epsilon^\prime\)</span>, or equivalently
that <span class="math notranslate nohighlight">\(\epsilon\le\epsilon^\prime\)</span>.
To achieve this we need to use an optimal step size, <span class="math notranslate nohighlight">\(h^\prime\)</span>,  that gives us exactly the desired error:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae6">
\[\tag{98}
\epsilon^\prime=c\frac{{h^\prime}^2}{2}.\]</div>
<p>Dividing equation <a class="reference internal" href="#eq-eq-ode-ae6"><span class="std std-ref">(98)</span></a> by equation <a class="reference internal" href="#eq-eq-ode-ae5b"><span class="std std-ref">(97)</span></a>, we can estimate the optimal step size:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae7">
\[\tag{99}
h^\prime=h\sqrt{\left|\frac{\epsilon^\prime}{\epsilon}\right|},\]</div>
<p>where the estimated error, <span class="math notranslate nohighlight">\(\epsilon\)</span>, is calculated from equation <a class="reference internal" href="#eq-eq-ode-ae5b"><span class="std std-ref">(97)</span></a>.
Equation <a class="reference internal" href="#eq-eq-ode-ae7"><span class="std std-ref">(99)</span></a> serves two purposes, if the estimated error <span class="math notranslate nohighlight">\(\epsilon\)</span> is higher than the tolerance, <span class="math notranslate nohighlight">\(\epsilon^\prime\)</span>, we have specified it will
give us an estimate for the step size we should choose in order to achieve a higher accuracy, if on the other hand <span class="math notranslate nohighlight">\(\epsilon^\prime &gt; \epsilon\)</span>, then we
get an estimate for the next, larger step. Before the implementation we note, as we did for the Romberg integration, that equation <a class="reference internal" href="#eq-eq-ode-ae5b"><span class="std std-ref">(97)</span></a>
also gives us an estimate for the error term in equation <a class="reference internal" href="#eq-eq-ode-aeb1"><span class="std std-ref">(95)</span></a> as an improved estimate of <span class="math notranslate nohighlight">\(y_1\)</span>. This we get for
free and will make our Euler algorithm accurate to <span class="math notranslate nohighlight">\(h^3\)</span>, hence the improved Euler step, <span class="math notranslate nohighlight">\(\hat{y_1}\)</span>, is to <em>subtract</em> the error
term from our previous estimate:</p>
<div class="math notranslate nohighlight" id="eq-auto60">
\[\tag{100}
\hat{y_1}=y_1-\epsilon=2y_1-y_1^*.\]</div>
<p>Below is an implementation of the adaptive Euler algorithm:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">one_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">c_old</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">c_in</span>

<span class="k">def</span> <span class="nf">adaptive_euler</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">c_in</span>    <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into tank</span>
    <span class="n">c_old</span>   <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span> <span class="n">h_new</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">;</span>
    <span class="n">toli</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span> <span class="c1"># a high init tolerance to enter while loop</span>
    <span class="n">no_steps</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">global_err</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="k">while</span><span class="p">(</span><span class="n">toli</span><span class="o">&gt;</span><span class="n">tol</span><span class="p">):</span><span class="c1"># first two small steps</span>
            <span class="n">hi</span><span class="o">=</span><span class="n">h_new</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">one_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">hi</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">k2</span> <span class="o">=</span> <span class="n">one_step</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">hi</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span>
            <span class="c1"># ... and one large step</span>
            <span class="n">k3</span> <span class="o">=</span> <span class="n">one_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">hi</span><span class="p">)</span>
            <span class="n">toli</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k3</span><span class="o">-</span><span class="n">k2</span><span class="p">)</span>
            <span class="n">h_new</span><span class="o">=</span><span class="n">hi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tol</span><span class="o">/</span><span class="n">toli</span><span class="p">)</span>
            <span class="n">no_steps</span><span class="o">+=</span><span class="mi">3</span>
        <span class="n">toli</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">c_old</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k2</span><span class="o">-</span><span class="n">k3</span> <span class="c1"># higher order correction</span>
 <span class="c1"># normal Euler, uncomment and inspect the global error</span>
 <span class="c1">#       c_old = k2</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">hi</span>
        <span class="n">global_err</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">-</span><span class="n">c_old</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;No steps=&quot;</span><span class="p">,</span> <span class="n">no_steps</span><span class="p">,</span> <span class="s2">&quot;Global Error=&quot;</span><span class="p">,</span> <span class="n">global_err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">f</span>
</pre></div>
</div>
<div class="figure" id="id5">
<span id="fig-ode-adapt-euler"></span><a class="reference internal image-reference" href="_images/adaptive_euler.png"><img alt="_images/adaptive_euler.png" src="_images/adaptive_euler.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>The concentration in the tank using adaptive Euler. Number of Euler steps are: 3006, 117, 48 and 36 for the different step sizes</em></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-adapt-euler"><span class="std std-ref">The concentration in the tank using adaptive Euler. Number of Euler steps are: 3006, 117, 48 and 36 for the different step sizes</span></a> the result of the implementation is shown.
Note that the number of steps for an accuracy of <span class="math notranslate nohighlight">\(10^{-6}\)</span> is only about 3000. Without knowing anything about the accuracy, we would have to assume
that we needed a step size of the order of <span class="math notranslate nohighlight">\(h\)</span> in order to reach a local accuracy of <span class="math notranslate nohighlight">\(h\)</span> because of equation <a class="reference internal" href="#eq-eq-ode-eu3"><span class="std std-ref">(87)</span></a>. In the current case,
we would have needed <span class="math notranslate nohighlight">\(10^7\)</span> steps, which would lead to unnecessary long simulation times.</p>
<div class="admonition-local-error-and-bounds admonition">
<p class="first admonition-title">Local error and bounds</p>
<p class="last">In the previous example we set an absolute tolerance, and required that our estimate <span class="math notranslate nohighlight">\(y_n\)</span> always is within a certain bound
of the true  solution <span class="math notranslate nohighlight">\(y(t_n)\)</span>, i.e. <span class="math notranslate nohighlight">\(|y(t_n)-y_n|\le\epsilon^\prime\)</span>. This is a very strong demand, and sometimes it makes more
sense to require that we also accept a relative tolerance proportional to function value. In some areas the solution might have a very large
value, and then another possibility would be to have an <span class="math notranslate nohighlight">\(\epsilon^\prime\)</span> that varied with the function value: <span class="math notranslate nohighlight">\(\epsilon^\prime = atol +|y|rtol\)</span>, where 'atol' is the absolute tolerance and 'rtol' is the relative tolerance. A sensible choice would be to set 'atol=rtol' (e.g. = <span class="math notranslate nohighlight">\(10^{-4}\)</span>).</p>
</div>
</div>
</div>
<div class="section" id="runge-kutta-methods">
<h2>Runge-Kutta Methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id6">
<span id="fig-ode-rk"></span><a class="reference internal image-reference" href="_images/rk_fig.png"><img alt="_images/rk_fig.png" src="_images/rk_fig.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Illustration of the Euler algorithm, and a motivation for using the slope a distance from the <span class="math notranslate nohighlight">\(t_n\)</span></span></p>
</div>
<p>The Euler method only have an accuracy of order <span class="math notranslate nohighlight">\(h\)</span>, and a global error that do not go to zero as the step size decrease.
The Runge-Kutta methods may be motivated by inspecting the Euler method in figure <a class="reference internal" href="#fig-ode-rk"><span class="std std-ref">Illustration of the Euler algorithm, and a motivation for using the slope a distance from the </span></a>. The Euler method uses information from
the previous time step to estimate the value at the new time step. The Runge Kutta methods uses the information about the slope between the
points <span class="math notranslate nohighlight">\(t_n\)</span> and <span class="math notranslate nohighlight">\(t_n+h\)</span>. By inspecting figure <a class="reference internal" href="#fig-ode-rk"><span class="std std-ref">Illustration of the Euler algorithm, and a motivation for using the slope a distance from the </span></a>, we clearly see that by using the slope at <span class="math notranslate nohighlight">\(t_n+h/2\)</span> would give us a
significant improvement. The 2. order Runge-Kutta method can be derived by Taylor expanding the solution around <span class="math notranslate nohighlight">\(t_n+h/2\)</span>, we do this by
setting <span class="math notranslate nohighlight">\(t_n+h=t_n+h/2+h/2\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rk1">
\[\tag{101}
y(t_n+h)=y(t_n+\frac{h}{2})+\frac{h}{2}\left.\frac{dy}{dt}\right|_{t=t_n+h/2}+\frac{h^2}{4}\left.\frac{d^2y}{dt^2}\right|_{t=t_n+h/2}
    +\mathcal{O}(h^3).\]</div>
<p>Similarly we can expand the solution in <span class="math notranslate nohighlight">\(y(t_n)\)</span> about <span class="math notranslate nohighlight">\(t_n+h/2\)</span>, by setting <span class="math notranslate nohighlight">\(t_n=t_n+h/2-h/2\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rk2">
\[\tag{102}
y(t_n)=y(t_n+\frac{h}{2})-\frac{h}{2}\left.\frac{dy}{dt}\right|_{t=t_n+h/2}+\frac{h^2}{4}\left.\frac{d^2y}{dt^2}\right|_{t=t_n+h/2}
    -\mathcal{O}(h^3).\]</div>
<p>Subtracting these two equations the term <span class="math notranslate nohighlight">\(y(t_n+\frac{h}{2})\)</span>, and all even powers in the derivative cancels out:</p>
<div class="math notranslate nohighlight">
\[y(t_n+h)=y(t_n)+h\left.\frac{dy}{dt}\right|_{t=t_n+h/2}+\mathcal{O}(h^3),\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-rk3">
\[\tag{103}
y(t_n+h)=y(t_n)+hf(y_{n+h/2},t_n+h/2)+\mathcal{O}(h^3).\]</div>
<p>In the last equation, we have used equation <a class="reference internal" href="#eq-eq-ode-ode"><span class="std std-ref">(85)</span></a>. Note that we now have an expression that is very similar to Eulers algorithm,
but it is accurate to order <span class="math notranslate nohighlight">\(h^3\)</span>. There is one problem, and that is that the function <span class="math notranslate nohighlight">\(f\)</span> is to be evaluated at the point <span class="math notranslate nohighlight">\(y_{n+1/2}=y(t_n+h/2)\)</span>
which we do not know. This can be fixed by using Eulers algorithm: <span class="math notranslate nohighlight">\(y_{n+1/2}=y_n+h/2f(y_n,t_n)\)</span>. We can do this even if Eulers algorithm is
only accurate to order <span class="math notranslate nohighlight">\(h^2\)</span>, because the <span class="math notranslate nohighlight">\(f\)</span> in equation <a class="reference internal" href="#eq-eq-ode-rk3"><span class="std std-ref">(103)</span></a> is multiplied by <span class="math notranslate nohighlight">\(h\)</span>, and thus our algorithm is still accurate
up to order <span class="math notranslate nohighlight">\(h^3\)</span>.</p>
<div class="admonition-the-2-order-runge-kutta admonition">
<p class="first admonition-title">The 2. order Runge-Kutta</p>
<div class="math notranslate nohighlight">
\[k_1=hf(y_n,t_n)\nonumber\]</div>
<div class="last math notranslate nohighlight">
\[k_2=hf(y_n+\frac{1}{2}k_1,t_n+h/2)\nonumber\]</div>
</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-rk4">
\[\tag{104}
y_{n+1}=y_n+k_2\]</div>
<p>Below is a Python implementation of equation <a class="reference internal" href="#eq-eq-ode-rk4"><span class="std std-ref">(104)</span></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">c_in</span><span class="o">-</span><span class="n">c_old</span>

<span class="k">def</span> <span class="nf">rk2_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">k1</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k2</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_old</span><span class="o">+</span><span class="n">k2</span>

<span class="k">def</span> <span class="nf">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">c_in</span>  <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into tank</span>
    <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="n">c_new</span> <span class="o">=</span> <span class="n">rk2_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_new</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">f</span>
</pre></div>
</div>
<div class="figure" id="id7">
<span id="fig-ode-rk2"></span><a class="reference internal image-reference" href="_images/rk2.png"><img alt="_images/rk2.png" src="_images/rk2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The concentration in the tank for different step size <span class="math notranslate nohighlight">\(\Delta t\)</span></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-rk2"><span class="std std-ref">The concentration in the tank for different step size </span></a> the result of the implementation is shown.
Note that when comparing Runge-Kutta 2. order with Eulers method,
see figure <a class="reference internal" href="#fig-ode-rk2"><span class="std std-ref">The concentration in the tank for different step size </span></a> and <a class="reference internal" href="#fig-ode-euler"><span class="std std-ref">The concentration in the tank for different step size </span></a>,
we of course have
the obvious result that a larger step size can be taken, without loosing numerical accuracy. It is also worth noting that we can take steps that
is larger than the tank volume. Eulers method failed whenever the time step was larger than one tank volume (<span class="math notranslate nohighlight">\(h=t/\tau&gt;1\)</span>), whereas the Runge-Kutta
method finds a physical solution for step sizes lower than twice the tank volume. If the step size is larger, we see that the concentration in the tank
increases, which is clearly unphysical.</p>
<p>The Runge-Kutta fourth order method is one of he most used methods, it is accurate to order <span class="math notranslate nohighlight">\(h^4\)</span>, and has an error of order <span class="math notranslate nohighlight">\(h^5\)</span>. The development of the
algorithm itself is similar to the 2. order method, but of course more involved. We just quote the result:</p>
<div class="admonition-the-4-order-runge-kutta admonition">
<p class="first admonition-title">The 4. order Runge-Kutta</p>
<div class="math notranslate nohighlight">
\[k_1=hf(y_n,t_n)\nonumber\]</div>
<div class="math notranslate nohighlight">
\[k_2=hf(y_n+\frac{1}{2}k_1,t_n+h/2)\nonumber\]</div>
<div class="math notranslate nohighlight">
\[k_3=hf(y_n+\frac{1}{2}k_2,t_n+h/2)\nonumber\]</div>
<div class="last math notranslate nohighlight">
\[k_4=hf(y_n+k_3,t_n+h)\nonumber\]</div>
</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-rk5">
\[\tag{105}
y_{n+1}=y_n+\frac{1}{6}(k_1+2k_2+2k_3+k_4)\]</div>
<p>Below is a Python implementation of equation <a class="reference internal" href="#eq-eq-ode-rk5"><span class="std std-ref">(105)</span></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">c_in</span><span class="o">-</span><span class="n">c_old</span>

<span class="k">def</span> <span class="nf">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">k1</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k2</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k3</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k4</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span>    <span class="n">k3</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_old</span><span class="o">+</span><span class="p">(</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k3</span><span class="o">+</span><span class="n">k4</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span>

<span class="k">def</span> <span class="nf">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">c_in</span>  <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into tank</span>
    <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="n">c_new</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_new</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">f</span>
</pre></div>
</div>
<div class="figure" id="id8">
<span id="fig-ode-rk4"></span><a class="reference internal image-reference" href="_images/rk4.png"><img alt="_images/rk4.png" src="_images/rk4.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The concentration in the tank for different step size <span class="math notranslate nohighlight">\(\Delta t\)</span></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-rk4"><span class="std std-ref">The concentration in the tank for different step size </span></a> the result of the implementation is shown.</p>
<div class="section" id="adaptive-step-size-runge-kutta-method">
<h3>Adaptive step size - Runge-Kutta Method<a class="headerlink" href="#adaptive-step-size-runge-kutta-method" title="Permalink to this headline">¶</a></h3>
<p>Just as we did with Eulers method, we can implement an adaptive method. The derivation is exactly the same, but this time our method is accurate to
fourth order, hence the error term is of order <span class="math notranslate nohighlight">\(h^5\)</span>. We start by taking one large step of size <span class="math notranslate nohighlight">\(h\)</span>, our estimate, <span class="math notranslate nohighlight">\(y_1^*\)</span> is related to the true
solution, <span class="math notranslate nohighlight">\(y(t_1)\)</span>, in the following way:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rka0">
\[\tag{106}
y^*_1=y(t_1)+ch^5,\]</div>
<p>Next, we take two steps of half the size, <span class="math notranslate nohighlight">\(h/2\)</span>, hence:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rka1">
\[\tag{107}
y_1=y(t)+2c\left(\frac{h}{2}\right)^5.\]</div>
<p>Subtracting equation <a class="reference internal" href="#eq-eq-ode-rka0"><span class="std std-ref">(106)</span></a> and <a class="reference internal" href="#eq-eq-ode-rka1"><span class="std std-ref">(107)</span></a>, we find an expression similar to equation <a class="reference internal" href="#eq-eq-ode-ae5"><span class="std std-ref">(96)</span></a>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rka2">
\[\tag{108}
\Delta\equiv y_1^*-y_1=c\frac{15}{16}h^5,\]</div>
<p>or <span class="math notranslate nohighlight">\(c=16\Delta/(15h^5)\)</span>. For the Euler scheme, <span class="math notranslate nohighlight">\(\Delta\)</span> also happened to be equal to the truncation error, but in this case it is:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rka5">
\[\tag{109}
\epsilon=2c\left(\frac{h}{2}\right)^5=\frac{\Delta}{15}\]</div>
<p>we want the local error, <span class="math notranslate nohighlight">\(\epsilon\)</span>, to be smaller than some tolerance, <span class="math notranslate nohighlight">\(\epsilon^\prime\)</span>.
The optimal step size, <span class="math notranslate nohighlight">\(h^\prime\)</span>,  that gives us exactly the desired error is then:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rka3">
\[\tag{110}
\epsilon^\prime=2c\left(\frac{{h^\prime}}{2}\right)^5.\]</div>
<p>Dividing equation <a class="reference internal" href="#eq-eq-ode-rka3"><span class="std std-ref">(110)</span></a> by equation <a class="reference internal" href="#eq-eq-ode-rka5"><span class="std std-ref">(109)</span></a>, we can estimate the optimal step size:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-rka4">
\[\tag{111}
h^\prime=h\left|\frac{\epsilon}{\epsilon}\right|^{1/5},\]</div>
<p><span class="math notranslate nohighlight">\(\epsilon\)</span> can be calculated from equation <a class="reference internal" href="#eq-eq-ode-rka5"><span class="std std-ref">(109)</span></a>. Below is an implementation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">c_in</span><span class="o">-</span><span class="n">c_old</span>

<span class="k">def</span> <span class="nf">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">k1</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k2</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k3</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="n">k4</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span>    <span class="n">k3</span><span class="p">,</span><span class="n">c_in</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_old</span><span class="o">+</span><span class="p">(</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k3</span><span class="o">+</span><span class="n">k4</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span>

<span class="k">def</span> <span class="nf">adaptive_ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">tau_inv</span> <span class="o">=</span> <span class="n">q</span><span class="o">/</span><span class="n">vol</span>
    <span class="n">c_in</span>    <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into tank</span>
    <span class="n">c_old</span>   <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span> <span class="n">h_new</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">toli</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span> <span class="c1"># a high init tolerance to enter while loop</span>
    <span class="n">no_steps</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">global_err</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">+</span> <span class="n">tol</span><span class="o">*</span><span class="n">c_old</span>
        <span class="k">while</span><span class="p">(</span><span class="n">toli</span><span class="o">&gt;</span><span class="n">tol</span><span class="p">):</span><span class="c1"># first two small steps</span>
            <span class="n">hi</span><span class="o">=</span><span class="n">h_new</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">hi</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">k2</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">hi</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span>
            <span class="c1"># ... and one large step</span>
            <span class="n">k3</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">hi</span><span class="p">)</span>
            <span class="n">toli</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k3</span><span class="o">-</span><span class="n">k2</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span>
            <span class="n">h_new</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">hi</span><span class="o">*</span><span class="p">(</span><span class="n">tol</span><span class="o">/</span><span class="n">toli</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.2</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">no_steps</span><span class="o">+=</span><span class="mi">3</span>
        <span class="n">toli</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">c_old</span><span class="o">=</span><span class="n">k2</span><span class="o">-</span><span class="p">(</span><span class="n">k3</span><span class="o">-</span><span class="n">k2</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">hi</span>
        <span class="n">global_err</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">-</span><span class="n">c_old</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;No steps=&quot;</span><span class="p">,</span> <span class="n">no_steps</span><span class="p">,</span> <span class="s2">&quot;Global Error=&quot;</span><span class="p">,</span> <span class="n">global_err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">f</span>
</pre></div>
</div>
<div class="figure" id="id9">
<span id="fig-ode-adaptive-rk4"></span><a class="reference internal image-reference" href="_images/adaptive_rk4.png"><img alt="_images/adaptive_rk4.png" src="_images/adaptive_rk4.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>The concentration in the tank for different step size  \( Delta t \) . Number of rk4 steps are: 138, 99, 72 and 66 for the different step sizes and 'rtol=0', for 'rtol=tol' the number of rk4 steps are 81, 72, 63, 63</em></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-adaptive-rk4"><span class="std std-ref">The concentration in the tank for different step size  \( Delta t \) . Number of rk4 steps are: 138, 99, 72 and 66 for the different step sizes and 'rtol=0', for 'rtol=tol' the number of rk4 steps are 81, 72, 63, 63</span></a> the result of the implementation is shown.
Note that we put a safety limit on the step size 'min(hi*(tol/toli)**(0.2),1)'.</p>
<p>In general we can use the same procedure any method accurate to order <span class="math notranslate nohighlight">\(h^p\)</span>, and you can easily verify that:</p>
<div class="admonition-error-term-and-step-size-for-a-math-h-p-method admonition">
<p class="first last admonition-title">Error term and step size for a <span class="math notranslate nohighlight">\(h^p\)</span> method</p>
</div>
<div class="math notranslate nohighlight" id="eq-auto61">
\[ \begin{align}\begin{aligned} \tag{112}
 \epsilon=\frac{|\Delta|}{2^p-1}=\frac{|y_1^*-y_1|}{2^p-1},\\.. _Eq:_auto62:\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} \tag{113}
 h^\prime=\beta h\left|\frac{\epsilon}{\epsilon_0}\right|^{\frac{1}{p+1}},\\.. _Eq:_auto63:\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} \tag{114}
 \hat{y_1}=y_1-\epsilon=\frac{2^{p-1}y_1-y_1^*}{2^{p-1}-1},\\where  \( \beta \)  is a safety factor  \( \beta\simeq0.8,0.9 \) , and you should always be careful that the step size do not become too large so that
the method breaks down. This can happens when  \( \epsilon \)  is very low, which may happen if  \( y_1^*\simeq y_1 \)  and/or if  \( y_1^*\simeq y_1\simeq 0 \) .\end{aligned}\end{align} \]</div>
</div>
<div class="section" id="conservation-of-mass">
<h3>Conservation of Mass<a class="headerlink" href="#conservation-of-mass" title="Permalink to this headline">¶</a></h3>
<p>A mathematical model of a physical system should always be formulated in such a way that it is
consistent with the laws of nature. In practical situations this statement is usually equivalent to state that
the mathematical model should respect conservation laws. The conservation laws can be conservation of mass, energy, momentum,
electrical charge, etc. In our
example with the mixing tank, we were able to derive an expression for the concentration of salt out of
the tank, equation <a class="reference internal" href="#eq-eq-ode-sol"><span class="std std-ref">(80)</span></a>, by <em>demanding</em> conservation of mass (see equation <a class="reference internal" href="#eq-eq-ode-cstr1"><span class="std std-ref">(77)</span></a>).</p>
<p>A natural question to ask is then: If our mathematical model respect conservation of mass, are we sure that our
solution method respect conservation of mass? We of course expect that
when the grid spacing approaches zero our numerical solution will get closer and closer to the analytical
solution. Clearly when <span class="math notranslate nohighlight">\(\Delta x\to 0\)</span>, the mass is conserved. So what is the problem? The problem is that in many practical problems
we cannot always have a step size that is small enough to ensure that our solution always is close enough to the analytical
solution. The physical system we consider might be very complicated (e.g. a model for the earth climate), and our ODE system could
be a very small part of a very big system. A very good test of any code is to investigate if the code respect
the conservation laws. If we know that our implementation respect e.g. mass conservation at the discrete level, we can easily
test mass conservation by summing up all the mass entering, and subtracting the mass out of and present in our system.
If the mass is not conserved exactly, there is a good chance that there is a bug in our implementation.</p>
<p>If we now turn to our system, we know that the total amount of salt in the system when we start is <span class="math notranslate nohighlight">\(C(0)V\)</span>.
The amount entering is zero, and the amount leaving each time step is <span class="math notranslate nohighlight">\(q(t)C(t)\Delta t\)</span>. Thus we should
expect that if we add the amount of salt in the tank to the amount that has left the system
we should always get an amount that is equal to the original amount. Alternatively, we expect
<span class="math notranslate nohighlight">\(\int_{t_0}^t qC(t)dt + C(t)V -C(0)V=0\)</span>. Adding the following code in the <code class="docutils literal notranslate"><span class="pre">while(ti</span> <span class="pre">&lt;=</span> <span class="pre">t_final):</span></code> loop:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mout</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="n">c_new</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dt</span>
<span class="n">mbal</span>  <span class="o">=</span> <span class="p">(</span><span class="n">c_new</span><span class="o">*</span><span class="n">vol</span><span class="o">+</span><span class="n">mout</span><span class="o">-</span><span class="n">vol</span><span class="o">*</span><span class="n">c_init</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vol</span><span class="o">*</span><span class="n">c_init</span><span class="p">)</span>
</pre></div>
</div>
<p>it is possible to calculate the amount of mass lost (note that we have used the
trapezoidal formula to calculate the integral). In the table below the fraction of mass lost relative to the original
amount is shown for the various numerical methods.</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="18%" />
<col width="14%" />
<col width="22%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">﻿$Delta t$</th>
<th class="head"><span class="math notranslate nohighlight">\(h\)</span></th>
<th class="head">Euler</th>
<th class="head">RK 2. order</th>
<th class="head">RK 4. order</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>900</td>
<td>0.9</td>
<td>-0.4500</td>
<td>0.3682</td>
<td>0.0776</td>
</tr>
<tr class="row-odd"><td>500</td>
<td>0.5</td>
<td>-0.2500</td>
<td>0.0833</td>
<td>0.0215</td>
</tr>
<tr class="row-even"><td>100</td>
<td>0.1</td>
<td>-0.0500</td>
<td>0.0026</td>
<td>0.0008</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>0.01</td>
<td>-0.0050</td>
<td>2.5E-05</td>
<td>8.3E-06</td>
</tr>
</tbody>
</table>
<p>We clearly see from the table that the Runge-Kutta methods performs better than Eulers method, but
<em>all of the methods violates mass balance</em>.</p>
<p>This might not be a surprise as we know that our numerical solution is always an approximation to the analytical solution. How can
we then formulate an algorithm that will respect conservation laws at the discrete level? It turns out that for Eulers method it is not
so difficult. Eulers algorithm at the discrete level (see equation <a class="reference internal" href="#eq-eq-ode-eu0"><span class="std std-ref">(81)</span></a>) is actually a two-step process: first we inject the fresh water while we remove the &quot;old`` fluid <em>and then we mix</em>. By thinking about the
problem this way, it makes more sense to calculate the mass out of the tank as <span class="math notranslate nohighlight">\(\sum_kq_kC_k\Delta t_k\)</span>. If we in our implementation calculates the mass out of the tank as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mout</span> <span class="o">+=</span> <span class="n">c_old</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dt</span>
<span class="n">mbal</span>  <span class="o">=</span> <span class="p">(</span><span class="n">c_new</span><span class="o">*</span><span class="n">vol</span><span class="o">+</span><span class="n">mout</span><span class="o">-</span><span class="n">vol</span><span class="o">*</span><span class="n">c_init</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vol</span><span class="o">*</span><span class="n">c_init</span><span class="p">)</span>
</pre></div>
</div>
<p>We easily find that the mass is exactly conserved at every time for Eulers method. The concentration in the tank will of course not be any closer to the
analytical solution, but if our mixing tank was part of a much bigger system we could make sure that the mass would always be conserved if we make
sure that the mass out of the tank and into the next part of the system was equal to <span class="math notranslate nohighlight">\(qC(t)\Delta t\)</span>.</p>
</div>
</div>
<div class="section" id="solving-a-set-of-ode-equations">
<h2>Solving a set of ODE equations<a class="headerlink" href="#solving-a-set-of-ode-equations" title="Permalink to this headline">¶</a></h2>
<p>What happens if we have more than one equation that needs to be solved? If we continue with our current example, we might be interested in what would happen
if we had multiple tanks in series. This could be a very simple model to describe the cleaning  of a salty lake by injecting fresh water into it, but at
the same time this lake was connected to two nearby fresh water lakes, as illustrated in figure <a class="reference internal" href="#fig-ode-cstr3"><span class="std std-ref">A simple model for cleaning a salty lake that is connected to two lakes down stream</span></a>. The weakest part of the model is the assumption about
complete mixing, in a practical situation we could enforce complete mixing with the salty water in the first tank by injecting fresh water at multiple point in the
lake. For the two next lakes, the degree of mixing is not obvious, but salt water is heavier than fresh water and therefore it would sink and mix with the fresh water. Thus
if the flow rate was slow, one might imaging that a more or less complete mixing could occur. Our model then could answer questions like, how long time would it take before most
of the salt water is removed from the first lake, and how much time would it take before most of the salt water was cleared from the whole system? The answer to
these questions would give practical input on how much and how fast one should inject the fresh water to clean up the system. If we had
data from an actual system, we could compare our model predictions with data from the physical system, and investigate if our model description was correct.</p>
<div class="figure" id="id10">
<span id="fig-ode-cstr3"></span><a class="reference internal image-reference" href="_images/cstr3.png"><img alt="_images/cstr3.png" src="_images/cstr3.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>A simple model for cleaning a salty lake that is connected to two lakes down stream</em></span></p>
</div>
<p>For simplicity we will assume that all the lakes have the same volume, <span class="math notranslate nohighlight">\(V\)</span>. The governing equations follows
as before, by assuming mass balance (equation <a class="reference internal" href="#eq-eq-ode-mbal"><span class="std std-ref">(76)</span></a>):</p>
<div class="math notranslate nohighlight">
\[C_0(t+\Delta t)\cdot V - C_0(t)\cdot V = q(t)\cdot C_\text{in}(t)\cdot \Delta t - q(t)\cdot C_0(t)\cdot \Delta t,\nonumber\]</div>
<div class="math notranslate nohighlight">
\[C_1(t+\Delta t)\cdot V - C_1(t)\cdot V = q(t)\cdot C_0(t)\cdot \Delta t - q(t)\cdot C_1(t)\cdot \Delta t,\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3a">
\[\tag{115}
C_2(t+\Delta t)\cdot V - C_2(t)\cdot V = q(t)\cdot C_1(t)\cdot \Delta t - q(t)\cdot C_2(t)\cdot \Delta t.\]</div>
<p>Taking the limit <span class="math notranslate nohighlight">\(\Delta t\to 0\)</span>, we can write equation <a class="reference internal" href="#eq-eq-ode-cstr3a"><span class="std std-ref">(115)</span></a> as:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3b">
\[\tag{116}
V\frac{dC_0(t)}{dt} = q(t)\left[C_\text{in}(t) - C_0(t)\right],\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3c">
\[\tag{117}
V\frac{dC_1(t)}{dt} = q(t)\left[C_0(t) - C_1(t)\right],\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3d">
\[\tag{118}
V\frac{dC_2(t)}{dt} = q(t)\left[C_1(t) - C_2(t)\right].\]</div>
<p>Let us first derive the analytical solution: Only the first tank is filled with salt water <span class="math notranslate nohighlight">\(C_0(0)=C_{0,0}\)</span>, <span class="math notranslate nohighlight">\(C_1(0)=C_2(0)=0\)</span>, and <span class="math notranslate nohighlight">\(C_\text{in}=0\)</span>.
The solution to equation <a class="reference internal" href="#eq-eq-ode-cstr3b"><span class="std std-ref">(116)</span></a> is, as before <span class="math notranslate nohighlight">\(C_0(t)=C_{0,0}e^{-t/\tau}\)</span>, inserting this equation into equation <a class="reference internal" href="#eq-eq-ode-cstr3c"><span class="std std-ref">(117)</span></a> we find:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3e">
\[\tag{119}
V\frac{dC_1(t)}{dt} = q(t)\left[C_{0,0}e^{-t/\tau} - C_1(t)\right]\,\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3f">
\[\tag{120}
\frac{d}{dt}\left[e^{t/\tau}C_1\right]= \frac{C_{0,0}}{\tau}\,\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3g">
\[\tag{121}
C_1(t)=\frac{C_{0,0}t}{\tau}e^{-t/\tau}\.\]</div>
<p>where we have use the technique of <a class="reference external" href="https://en.wikipedia.org/wiki/Integrating_factor">integrating factors</a> when going from equation <a class="reference internal" href="#eq-eq-ode-cstr3e"><span class="std std-ref">(119)</span></a> to <a class="reference internal" href="#eq-eq-ode-cstr3f"><span class="std std-ref">(120)</span></a>.
Inserting equation <a class="reference internal" href="#eq-eq-ode-cstr3g"><span class="std std-ref">(121)</span></a> into equation <a class="reference internal" href="#eq-eq-ode-cstr3d"><span class="std std-ref">(118)</span></a>, solving the equation in a similar way as for <span class="math notranslate nohighlight">\(C_1\)</span> we find:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3h">
\[\tag{122}
V\frac{dC_2(t)}{dt} = q(t)\left[\frac{C_{0,0}t}{\tau}e^{-t/\tau} - C_2(t)\right],\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3i">
\[\tag{123}
\frac{d}{dt}\left[e^{t/\tau}C_2\right]= \frac{C_{0,0}t}{\tau},\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr3j">
\[\tag{124}
C_2(t)=\frac{C_{0,0}t^2}{2\tau^2}e^{-t/\tau}.\]</div>
<dl class="docutils">
<dt>The numerical solution follows the exact same pattern as before if we introduce a vector notation. Before doing that, we rescale the time <span class="math notranslate nohighlight">\(t\to t/\tau\)</span> and the concentrations,</dt>
<dd><span class="math notranslate nohighlight">\(\hat{C_i}=C_i/C_{0,0}\)</span> for <span class="math notranslate nohighlight">\(i=0,1,2\)</span>, hence:</dd>
</dl>
<div class="math notranslate nohighlight" id="eq-auto64">
\[\tag{125}
\frac{d}{dt}
    \begin{bmatrix}
     \hat{C_0}(t)\]</div>
<div class="math notranslate nohighlight" id="eq-auto65">
\[\tag{126}
\hat{C_1}(t)\]</div>
<div class="math notranslate nohighlight" id="eq-auto66">
\[\tag{127}
\hat{C_2}(t)
     \end{bmatrix}
    =  \begin{bmatrix}
     \hat{C_\text{in}}(t) - \hat{C_0}(t)\]</div>
<div class="math notranslate nohighlight" id="eq-auto67">
\[\tag{128}
\hat{C_0}(t) - \hat{C_1}(t)\]</div>
<div class="math notranslate nohighlight">
\[\hat{C_1}(t) - \hat{C_2}(t)
\end{bmatrix},\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto68">
\[\tag{129}
\frac{d\mathbf{\hat{C}}(t)}{dt}=\mathbf{f}(\mathbf{\hat{C}},t).\]</div>
<p>Below is an implementation using the Runge Kutta 4. order method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">tau</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">c_in</span><span class="o">-</span><span class="n">c_old</span><span class="p">)</span><span class="o">/</span><span class="n">tau</span>

<span class="k">def</span> <span class="nf">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">c_next</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c_old</span><span class="p">)):</span>
        <span class="n">k1</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">k2</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span><span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">k3</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span><span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">k4</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span>    <span class="n">k3</span><span class="p">,</span><span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">c_next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k3</span><span class="o">+</span><span class="n">k4</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_next</span>

<span class="k">def</span> <span class="nf">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">c_in</span>  <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into first tank</span>
    <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="n">c_new</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_new</span>
        <span class="c1"># put concentration of tank 0 into tank 1 etc.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_old</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">ci</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">1e-2</span>
<span class="c1"># initial values</span>
<span class="n">vol</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">c_into</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">c_init</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">tau</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span><span class="n">t_final</span><span class="o">=</span><span class="mi">10</span> <span class="c1"># end of simulation</span>
<span class="n">t</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="id11">
<span id="fig-ode-rk4-2"></span><a class="reference internal image-reference" href="_images/rk4_2.png"><img alt="_images/rk4_2.png" src="_images/rk4_2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>The concentration in the tanks</em></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-rk4-2"><span class="std std-ref">The concentration in the tanks</span></a> the result of the implementation is shown.</p>
</div>
<div class="section" id="stiff-sets-of-ode-and-implicit-methods">
<h2>Stiff sets of ODE  and implicit methods<a class="headerlink" href="#stiff-sets-of-ode-and-implicit-methods" title="Permalink to this headline">¶</a></h2>
<p>As already mentioned a couple of times, our system could be part of a much larger system. To illustrate this, let us now assume that we have two
tanks in series. The first tank is similar to our original tank, but the second tank is a sampling tank, 1000 times smaller.</p>
<div class="figure" id="id12">
<span id="fig-ode-cstr2"></span><a class="reference internal image-reference" href="_images/cstr2.png"><img alt="_images/cstr2.png" src="_images/cstr2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>A continuous stirred tank model with a sampling vessel</em></span></p>
</div>
<p>The governing equations can be found by requiring mass balance for each of the tanks (see equation <a class="reference internal" href="#eq-eq-ode-mbal"><span class="std std-ref">(76)</span></a>:</p>
<div class="math notranslate nohighlight">
\[C_0(t+\Delta t)\cdot V_0 - C_0(t)\cdot V_0 = q(t)\cdot C_\text{in}(t)\cdot \Delta t - q(t)\cdot C_0(t)\cdot \Delta t.\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2a">
\[\tag{130}
C_1(t+\Delta t)\cdot V_1 - C_1(t)\cdot V_1 = q(t)\cdot C_0(t)\cdot \Delta t - q(t)\cdot C_1(t)\cdot \Delta t.
    \]</div>
<p>Taking the limit <span class="math notranslate nohighlight">\(\Delta t\to 0\)</span>, we can write equation <a class="reference internal" href="#eq-eq-ode-cstr2a"><span class="std std-ref">(130)</span></a> as:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2bb">
\[\tag{131}
V_0\frac{dC_0(t)}{dt} = q(t)\left[C_\text{in}(t) - C_0(t)\right].\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2b">
\[\tag{132}
V_1\frac{dC_1(t)}{dt} = q(t)\left[C_0(t) - C_1(t)\right].\]</div>
<p>Assume that the first tank is filled with seawater, <span class="math notranslate nohighlight">\(C_0(0)=C_{0,0}\)</span>, and fresh water is flooded into the tank, i.e. <span class="math notranslate nohighlight">\(C_\text{in}=0\)</span>. Before we start to consider a numerical
solution, let us first find the analytical solution: As before the solution for the first tank (equation <a class="reference internal" href="#eq-eq-ode-cstr2bb"><span class="std std-ref">(131)</span></a>) is:</p>
<div class="math notranslate nohighlight" id="eq-auto69">
\[\tag{133}
C_0(t)=C_{0,0}e^{-t/\tau_0},\]</div>
<p>where <span class="math notranslate nohighlight">\(\tau_0\equiv V_0/q\)</span>. Inserting this equation into equation <a class="reference internal" href="#eq-eq-ode-cstr2b"><span class="std std-ref">(132)</span></a>, we get:</p>
<div class="math notranslate nohighlight">
\[\frac{dC_1(t)}{dt} = \frac{1}{\tau_1}\left[C_{0,0}e^{-t/\tau_0} - C_1(t)\right],\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2c">
\[\tag{134}
\frac{d}{dt}\left[e^{t/\tau_2}C_1\right]= \frac{C_{0,0}}{\tau_1}e^{-t(1/\tau_0-1/\tau_1)}\,\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2d">
\[\tag{135}
C_1(t)=\frac{C_{0,0}}{1-\frac{\tau_1}{\tau_0}}\left[e^{-t/\tau_0}-e^{-t/\tau_1}\right],\]</div>
<p>where <span class="math notranslate nohighlight">\(\tau_1\equiv V_1/q\)</span>.</p>
<p>Next, we will consider the numerical solution. You might think that these equations are more simple to solve numerically than the equations with three tanks
in series discussed in the previous section. Actually, this system is much harder to solve with the methods we have discussed so far.
The reason is that there are now <em>two time scales</em> in the system, <span class="math notranslate nohighlight">\(\tau_1\)</span> and <span class="math notranslate nohighlight">\(\tau_2\)</span>. The smaller tank sets a strong limitation on the step size
we can use, because we should never use step sizes larger than a tank volume. Thus if you use the code in the previous section to solve equation
<a class="reference internal" href="#eq-eq-ode-cstr2bb"><span class="std std-ref">(131)</span></a> and <a class="reference internal" href="#eq-eq-ode-cstr2b"><span class="std std-ref">(132)</span></a>, it will not find the correct solution, unless the step size is lower than <span class="math notranslate nohighlight">\(10^{-3}\)</span>. Equations of this type
are known as <em>stiff</em>.</p>
<div class="admonition-stiff-equations admonition">
<p class="first admonition-title">Stiff equations</p>
<p class="last">There is no precise definition of &quot;stiff'', but it is used to describe a system of differential equations, where the numerical solution becomes unstable unless
a very small step size is chosen. Such systems occurs because there are several (length, time) scales in the system, and the numerical solution is constrained
by the shortest length scale. You should always be careful on how you scale your variables in order to make the system dimensionless, which is of
particular importance when you use adaptive methods.</p>
</div>
<p>These types of equations are often encountered in practical applications. If our sampling tank was extremely small, maybe <span class="math notranslate nohighlight">\(10^6\)</span> smaller than the chemical
reactor, then we would need a step size of the order of <span class="math notranslate nohighlight">\(10^{-8}\)</span> or lower to solve the system. This step size is so low that we easily run into trouble
with round off errors in the computer. In addition the simulation time is extremely long.  How do we deal with this problem? The solution is actually
quite simple. The reason we run into trouble is that we require that the concentration leaving the tank must be a small perturbation of the old one.
This is not necessary, and it is best illustrated with Eulers method. As explained earlier Eulers method can be viewed as a two step process:
first we inject a volume (and remove an equal amount: <span class="math notranslate nohighlight">\(qC(t)\Delta t\)</span>), and then we mix. Clearly when we try to remove more than what is left, we run into
trouble. What we want to do is to remove or flood much more than one tank volume through the tank during one time step, this can be achieved by
<span class="math notranslate nohighlight">\(q(t)C(t)\Delta t\to q(t+\Delta t)C(t+\Delta t)\Delta t\)</span>. The term <span class="math notranslate nohighlight">\(q(t+\Delta t)C(t+\Delta t)\Delta t\)</span> now represents
<em>the mass out of the system during the time step $Delta t$</em>.</p>
<p>The methods we have considered so far are known as <em>explicit</em>, whenever we replace the solution in the right hand side of our algorithm with <span class="math notranslate nohighlight">\(y(t+\Delta t)\)</span>
or (<span class="math notranslate nohighlight">\(y_{n+1}\)</span>),
the method is known as <em>implicit</em>. Implicit methods are always stable, meaning that we can take as large a time step that we would like, without
getting oscillating solution. It does not mean that we will get a more accurate solution, actually explicit methods are usually more accurate.</p>
<div class="admonition-explicit-and-implicit-methods admonition">
<p class="first admonition-title">Explicit and Implicit methods</p>
<p class="last">Explicit methods are often called <em>forward</em> methods, as they use only information from the previous step to estimate the next value. The explicit
methods are easy to implement, but get into trouble if the step size is too large. Implicit methods are often called <em>backward</em> methods as the next
step cannot be calculated directly from the previous solution, usually a non-linear equation has to be solved. Implicit methods are generally much
more stable, but the price is often lower accuracy. Many commercial simulators uses implicit methods extensively because they are stable, and stability is often viewed
as a much more important criterion than numerical accuracy.</p>
</div>
<p>Let us consider our example further, and for simplicity use the implicit Eulers method:</p>
<div class="math notranslate nohighlight">
\[{C_0}_{n+1}V_0 - {C_0}_nV_0 = q(t+\Delta t){C_\text{in}}_{n+1}\Delta t -
q(t+\Delta t){C_0}_{n+1}\Delta t.\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstr2ai">
\[\tag{136}
{C_1}_{n+1}V_1 - {C_1}_nV_1 = q(t+\Delta t){C_0}_{n+1}\Delta t - q(t+\Delta t){C_1}_{n+1}\Delta t.
    \]</div>
<p>This equation is equal to equation <a class="reference internal" href="#eq-eq-ode-cstr2a"><span class="std std-ref">(130)</span></a>, but the concentrations on the right hand side are now evaluated at the next time step.
The immediate problem is now that we have to find an expression for <span class="math notranslate nohighlight">\(C_{n+1}\)</span> that is given in terms of known variables. In most cases one needs
to use a root finding method, like Newtons method, in order to solve equation <a class="reference internal" href="#eq-eq-ode-cstr2ai"><span class="std std-ref">(136)</span></a>. In this case it is straight forward to show:</p>
<div class="math notranslate nohighlight">
\[{C_0}_{n+1}=\frac{{C_0}_n + \frac{\Delta t}{\tau_0}{C_\text{in}}_{n+1}}{1+\frac{\Delta t}{\tau_0}},\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-cstri1">
\[\tag{137}
{C_2}_{n+1}=\frac{{C_1}_n + \frac{\Delta t}{\tau_1}{C_0}_{n+1}}{1+\frac{\Delta t}{\tau_1}}.\]</div>
<p>Below is an implementation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">c_old</span><span class="o">+</span><span class="n">c_in</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">euler_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span> <span class="n">c_in</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">c_next</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c_old</span><span class="p">)):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span> <span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">c_next</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># c_new in next tank</span>
        <span class="n">c_next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fm</span><span class="p">(</span><span class="n">c_old</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">h</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">c_next</span>

<span class="k">def</span> <span class="nf">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="n">f</span><span class="o">=</span><span class="p">[];</span><span class="n">t</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">c_in</span>  <span class="o">=</span> <span class="n">c_into</span> <span class="c1">#freshwater into first tank</span>
    <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_init</span> <span class="c1">#seawater present</span>
    <span class="n">ti</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span> <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span>
        <span class="n">c_new</span> <span class="o">=</span> <span class="n">euler_step</span><span class="p">(</span><span class="n">c_old</span><span class="p">,</span><span class="n">c_in</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">c_old</span> <span class="o">=</span> <span class="n">c_new</span>
        <span class="c1"># put concentration of tank 0 into tank 1 etc.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_old</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">c_old</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">c_in</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">ci</span>
        <span class="n">ti</span>   <span class="o">+=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="c1"># initial values</span>
<span class="n">vol</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">c_into</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">c_init</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">tau</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">];</span><span class="n">t_final</span><span class="o">=</span><span class="mi">10</span> <span class="c1"># end of simulation</span>
<span class="n">t</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">ode_solv</span><span class="p">(</span><span class="n">c_into</span><span class="p">,</span><span class="n">c_init</span><span class="p">,</span><span class="n">t_final</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="id13">
<span id="fig-ode-euler-imp"></span><a class="reference internal image-reference" href="_images/euler_imp.png"><img alt="_images/euler_imp.png" src="_images/euler_imp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The concentration in the tanks for <span class="math notranslate nohighlight">\(h=0.01\)</span></span></p>
</div>
<p>In figure <a class="reference internal" href="#fig-ode-euler-imp"><span class="std std-ref">The concentration in the tanks for </span></a> the result of the implementation is shown.</p>
<div class="section" id="exercise-3-1-truncation-error-in-eulers-method">
<h3>Exercise 3.1: Truncation Error in Eulers Method<a class="headerlink" href="#exercise-3-1-truncation-error-in-eulers-method" title="Permalink to this headline">¶</a></h3>
<p>In the following we will take a closer look at the adaptive Eulers algorithm and show that the
constant <span class="math notranslate nohighlight">\(c\)</span> is indeed the same in equation <a class="reference internal" href="#eq-eq-ode-aeb0"><span class="std std-ref">(94)</span></a> and <a class="reference internal" href="#eq-eq-ode-aeb1"><span class="std std-ref">(95)</span></a>.
The true solution <span class="math notranslate nohighlight">\(y(t)\)</span>, obeys the following equation:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay">
\[\tag{138}
\frac{dy}{dt}=f(y,t),\]</div>
<p>and Eulers method to get from <span class="math notranslate nohighlight">\(y_0\)</span> to <span class="math notranslate nohighlight">\(y_1\)</span> by taking one (large) step, <span class="math notranslate nohighlight">\(h\)</span> is:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae0">
\[\tag{139}
y^*_1=y_0+hf(y_0,t_0),\]</div>
<p>We will also assume (for simplicity) that in our starting point <span class="math notranslate nohighlight">\(t=t_0\)</span>, the numerical solution, <span class="math notranslate nohighlight">\(y_0\)</span>, is equal to the true solution, <span class="math notranslate nohighlight">\(y(t_0)\)</span>, hence <span class="math notranslate nohighlight">\(y(t_0)=y_0\)</span>.</p>
<p><strong>a)</strong>
Show that when we take one step of size <span class="math notranslate nohighlight">\(h\)</span> from <span class="math notranslate nohighlight">\(t_0\)</span> to <span class="math notranslate nohighlight">\(t_1=t_0+h\)</span>, <span class="math notranslate nohighlight">\(c=y^{\prime\prime}(t_0)/2\)</span> in equation <a class="reference internal" href="#eq-eq-ode-aeb0"><span class="std std-ref">(94)</span></a>.</p>
<p><strong>Answer.</strong>
The local error, is the difference between the numerical solution and the true solution:</p>
<div class="math notranslate nohighlight">
\[\epsilon^*=y(t_0+h)-y_{1}^*=y(t_0)+y^{\prime}(t_0)h+\frac{1}{2}y^{\prime\prime}(t_0)h^2+\mathcal{O}(h^3)\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto70">
\[\tag{140}
-\left[y_0+hf(y_0,t_0+h)\right],\]</div>
<p>where we have used Taylor expansion to expand the true solution around <span class="math notranslate nohighlight">\(t_0\)</span>, and equation <a class="reference internal" href="#eq-eq-ode-ae0"><span class="std std-ref">(139)</span></a>.
Using equation <a class="reference internal" href="#eq-eq-ode-ay"><span class="std std-ref">(138)</span></a> to replace <span class="math notranslate nohighlight">\(y^\prime(t_0)\)</span> with <span class="math notranslate nohighlight">\(f(y_0,t_0)\)</span>, we find:</p>
<div class="math notranslate nohighlight" id="eq-auto71">
\[\tag{141}
\epsilon^*=y(t_0+h)-y_{1}^*=\frac{1}{2}y^{\prime\prime}(t_0)h^2\equiv ch^2,\]</div>
<p>hence <span class="math notranslate nohighlight">\(c=y^{\prime\prime}(t_0)/2\)</span>.</p>
<p><strong>b)</strong>
Show that when we take two steps of size <span class="math notranslate nohighlight">\(h/2\)</span> from <span class="math notranslate nohighlight">\(t_0\)</span> to <span class="math notranslate nohighlight">\(t_1=t_0+h\)</span>, Eulers algorithm is:</p>
<div class="math notranslate nohighlight" id="eq-auto72">
\[\tag{142}
y_{1}=y_{0}+\frac{h}{2}f(y_0,t_0)+\frac{h}{2}f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2).\]</div>
<p><strong>Answer.</strong></p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae1b">
\[\tag{143}
y_{1/2}=y_0+\frac{h}{2}f(y_0,t_0),\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae2b">
\[\tag{144}
y_{1}=y_{1/2}+\frac{h}{2}f(y_{1/2},t_0+h/2),\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae3b">
\[\tag{145}
y_{1}=y_{0}+\frac{h}{2}f(y_0,t_0)+\frac{h}{2}f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2).\]</div>
<p>Note that we have inserted
equation <a class="reference internal" href="#eq-eq-ode-ae1b"><span class="std std-ref">(143)</span></a> into equation <a class="reference internal" href="#eq-eq-ode-ae2b"><span class="std std-ref">(144)</span></a> to arrive at equation <a class="reference internal" href="#eq-eq-ode-ae3b"><span class="std std-ref">(145)</span></a>.</p>
<p><strong>c)</strong>
Find an expression for the local error when using two steps of size <span class="math notranslate nohighlight">\(h/2\)</span>, and show that the local error is: <span class="math notranslate nohighlight">\(\frac{1}{2}ch^2\)</span></p>
<p><strong>Answer.</strong></p>
<div class="math notranslate nohighlight">
\[\epsilon=y(t_0+h)-y_{1}=y(t_0)+y^{\prime}(t_0)h+\frac{1}{2}y^{\prime\prime}(t_0)h^2+\mathcal{O}(h^3)\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay5b">
\[\tag{146}
-\left[y_{0}+\frac{h}{2}f(y_0,t_0)+\frac{h}{2}f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2)\right].\]</div>
<p>This equation is slightly more complicated, due to the term involving <span class="math notranslate nohighlight">\(f\)</span> inside the last parenthesis, we can use Taylor expansion to expand it about <span class="math notranslate nohighlight">\((y_0,t_0)\)</span>:</p>
<div class="math notranslate nohighlight">
\[f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2)=f(y_0,t_0)\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay2b">
\[\tag{147}
+\frac{h}{2}\left[f(y_0,t_0)\left.\frac{\partial f}{\partial y}\right|_{y=y_0,t=t_0}
    +\frac{h}{2}\left.\frac{\partial f}{\partial t}\right|_{y=y_0,t=t_0}\right]+\mathcal{O}(h^2).\]</div>
<p>It turns out that this equation is related to <span class="math notranslate nohighlight">\(y^{\prime\prime}(t_0,y_0)\)</span>, which can be seen by differentiating equation <a class="reference internal" href="#eq-eq-ode-ay"><span class="std std-ref">(138)</span></a>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay3b">
\[\tag{148}
\frac{d^2y}{dt^2}=\frac{df(y,t)}{dt}=\frac{\partial f(y,t)}{\partial y}\frac{dy}{dt}+\frac{\partial f(y,t)}{\partial t}
    =\frac{\partial f(y,t)}{\partial y}f(y,t)+\frac{\partial f(y,t)}{\partial t}.\]</div>
<p>Hence, equation <a class="reference internal" href="#eq-eq-ode-ay2b"><span class="std std-ref">(147)</span></a> can be written:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay4b">
\[\tag{149}
f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2)=f(y_0,t_0)+\frac{h}{2}y^{\prime\prime}(t_0,y_0),\]</div>
<p>hence the truncation error in equation <a class="reference internal" href="#eq-eq-ode-ay5b"><span class="std std-ref">(146)</span></a> can finally be written:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae4b">
\[\tag{150}
\epsilon=y(t_1)-y_{1}=\frac{h^2}{4} y^{\prime\prime}(y_0,t_0)=\frac{1}{2}ch^2,\]</div>
<p><a class="reference internal" href="._book005.html#ref1" id="id2">[Ref1]</a></p>
<p><strong>Solution.</strong>
The local error, is the difference between the numerical solution and the true solution:</p>
<div class="math notranslate nohighlight">
\[\epsilon^*=y(t_0+h)-y_{1}^*=y(t_0)+y^{\prime}(t_0)h+\frac{1}{2}y^{\prime\prime}(t_0)h^2+\mathcal{O}(h^3)\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto73">
\[\tag{151}
-\left[y_0+hf(y_0,t_0+h)\right],\]</div>
<p>where we have used Taylor expansion to expand the true solution around <span class="math notranslate nohighlight">\(t_0\)</span>, and equation <a class="reference internal" href="#eq-eq-ode-ae0"><span class="std std-ref">(139)</span></a>.
Using equation <a class="reference internal" href="#eq-eq-ode-ay"><span class="std std-ref">(138)</span></a> to replace <span class="math notranslate nohighlight">\(y^\prime(t_0)\)</span> with <span class="math notranslate nohighlight">\(f(y_0,t_0)\)</span>, we find:</p>
<div class="math notranslate nohighlight" id="eq-auto74">
\[\tag{152}
\epsilon^*=y(t_0+h)-y_{1}^*=\frac{1}{2}y^{\prime\prime}(t_0)h^2\equiv ch^2,\]</div>
<p>where we have ignored terms of higher order than <span class="math notranslate nohighlight">\(h^2\)</span>, and defined <span class="math notranslate nohighlight">\(c\)</span> as <span class="math notranslate nohighlight">\(c=y^{\prime\prime}(t_0)/2\)</span>. Next we take two steps of size <span class="math notranslate nohighlight">\(h/2\)</span> to
reach <span class="math notranslate nohighlight">\(y_1\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae1">
\[\tag{153}
y_{1/2}=y_0+\frac{h}{2}f(y_0,t_0),\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae2">
\[\tag{154}
y_{1}=y_{1/2}+\frac{h}{2}f(y_{1/2},t_0+h/2),\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae3">
\[\tag{155}
y_{1}=y_{0}+\frac{h}{2}f(y_0,t_0)+\frac{h}{2}f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2).\]</div>
<p>Note that we have inserted
equation <a class="reference internal" href="#eq-eq-ode-ae1"><span class="std std-ref">(153)</span></a> into equation <a class="reference internal" href="#eq-eq-ode-ae2"><span class="std std-ref">(154)</span></a> to arrive at equation <a class="reference internal" href="#eq-eq-ode-ae3"><span class="std std-ref">(155)</span></a>. The truncation error in this case is, as before:</p>
<div class="math notranslate nohighlight">
\[\epsilon=y(t_0+h)-y_{1}=y(t_0)+y^{\prime}(t_0)h+\frac{1}{2}y^{\prime\prime}(t_0)h^2+\mathcal{O}(h^3)\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay5">
\[\tag{156}
-\left[y_{0}+\frac{h}{2}f(y_0,t_0)+\frac{h}{2}f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2)\right].\]</div>
<p>This equation is slightly more complicated, due to the term involving <span class="math notranslate nohighlight">\(f\)</span> inside the last parenthesis, we can use Taylor expansion to expand it about <span class="math notranslate nohighlight">\((y_0,t_0)\)</span>:</p>
<div class="math notranslate nohighlight">
\[f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2)=f(y_0,t_0)\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay2">
\[\tag{157}
+\frac{h}{2}\left[f(y_0,t_0)\left.\frac{\partial f}{\partial y}\right|_{y=y_0,t=t_0}
    +\left.\frac{\partial f}{\partial t}\right|_{y=y_0,t=t_0}\right]+\mathcal{O}(h^2).\]</div>
<p>It turns out that this equation is related to <span class="math notranslate nohighlight">\(y^{\prime\prime}(t_0,y_0)\)</span>, which can be seen by differentiating equation <a class="reference internal" href="#eq-eq-ode-ay"><span class="std std-ref">(138)</span></a>:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay3">
\[\tag{158}
\frac{d^2y}{dt^2}=\frac{df(y,t)}{dt}=\frac{\partial f(y,t)}{\partial y}\frac{dy}{dt}+\frac{\partial f(y,t)}{\partial t}
    =\frac{\partial f(y,t)}{\partial y}f(y,t)+\frac{\partial f(y,t)}{\partial t}.\]</div>
<p>Hence, equation <a class="reference internal" href="#eq-eq-ode-ay2"><span class="std std-ref">(157)</span></a> can be written:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ay4">
\[\tag{159}
f(y_0+\frac{h}{2}f(y_0,t_0),t_0+h/2)=f(y_0,t_0)+\frac{h}{2}y^{\prime\prime}(t_0,y_0),\]</div>
<p>hence the truncation error in equation <a class="reference internal" href="#eq-eq-ode-ay5"><span class="std std-ref">(156)</span></a> can finally be written:</p>
<div class="math notranslate nohighlight" id="eq-eq-ode-ae4">
\[\tag{160}
\epsilon=y(t_1)-y_{1}=\frac{h^2}{4} y^{\prime\prime}(y_0,t_0)=\frac{1}{2}ch^2,\]</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Ordinary differential equations</a><ul>
<li><a class="reference internal" href="#id1">Ordinary Differential Equations</a></li>
<li><a class="reference internal" href="#a-simple-model-for-fluid-flow">A Simple Model for Fluid Flow</a></li>
<li><a class="reference internal" href="#eulers-method">Eulers Method</a><ul>
<li><a class="reference internal" href="#error-analysis-eulers-method">Error Analysis - Eulers Method</a></li>
<li><a class="reference internal" href="#adaptive-step-size-eulers-method">Adaptive step size - Eulers Method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#runge-kutta-methods">Runge-Kutta Methods</a><ul>
<li><a class="reference internal" href="#adaptive-step-size-runge-kutta-method">Adaptive step size - Runge-Kutta Method</a></li>
<li><a class="reference internal" href="#conservation-of-mass">Conservation of Mass</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solving-a-set-of-ode-equations">Solving a set of ODE equations</a></li>
<li><a class="reference internal" href="#stiff-sets-of-ode-and-implicit-methods">Stiff sets of ODE  and implicit methods</a><ul>
<li><a class="reference internal" href="#exercise-3-1-truncation-error-in-eulers-method">Exercise 3.1: Truncation Error in Eulers Method</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="._book003.html" title="previous chapter">Numerical integration</a></li>
      <li>Next: <a href="._book005.html" title="next chapter">References</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book004.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Aksel Hiorth, the National IOR Centre & Institute for Energy Resources,.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/._book004.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>