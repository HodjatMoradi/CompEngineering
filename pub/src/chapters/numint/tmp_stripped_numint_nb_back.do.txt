Numerical Integration Notebook 
Learning objectives:  being able to implement a numerical algorithm in python  quantify numerical uncertainty  test different methods and have basic understanding of the strength and weaknesses of each method The Trapezoidal Rule 
In the lecture notes it was shown that the algorithm for the trapezoidal rule was:

Exercise: Implementing the trapezoidal rule in Python 
Whenever implementing an algorithm it is always important to be absolutely sure that we have implemented it correctly. We always use functions that we know the true answer. As a test function you could use or any other function (g. etc.) and choose a reasonable integration domain. First: o Show that the analytical result is 
o Show that if, equation would give 
Use the formula in equation to develop a python function that takes as argument the integration limits, the function to be integrated and the number of integration points: Test the code for, increase and compare with the analytical result (2).  By increasing the numerical result will get closer to the true answer. How much do you need to increase in order to reach an accuracy higher than ?  Show that the error term for the trapezoidal rule is: How does the numerical error compares with the analytical error?

Exercise: Choose number of steps automatically for the trapezoidal rule 
In practical applications we would like to just enter the accuracy we would like, and then expect our algorithm to figure out the number of steps. Change the code in the exercise above to calculate the value of the integral using a tolerance as input, instead of. (The step size can be calculated from equation 

Exercise: Practical error estimate of numerical integrals 
Assume that we estimate an integral using a step size of and. The resulting estimates are and respectively. Show that the higher order error term for is:


Make a Python implementation of the trapezoidal rule that uses this method to calculate the integral to a specific tolerance:


Hint: To improve the efficiency of the code, you only need to calculate the odd terms in the next estimate of the area, using the algorithm in the compendium: Compare the number of function evaluation for an error of using the algorithm in this exercise and the previous for the following integrals:  
Exercise: Adaptive integration - Rombergs algorithm 
In this exercise we will implement the Romberg algorithm, which is actually closely related to the adaptive trapezoidal rule in the previous exercise. The algorithm uses the technique from the previous exercise by halving the step size to estimate the error, but an additional trick is used: When we have the error estimate, we can add the error estimate to our numerical estimate of the integral to obtain a higher order accuracy. The algorithm is explained in the compendium and the result is:

Below is a graphical illustration of the algorithm:




You can check your implementation by comparing with the implementation in SciPy, Romberg: o Compare the adaptive trapezoidal rule and the Romberg algorithm for. Notice the extreme improvement by the Romberg algorithm.


Exercise: Evaluate 
We will now look closer at an integral where the derivative has a singularity in the integration domain. We will consider the integral: Compare the adaptive trapezoidal rule and the Romberg algorithm. Note that in this case the trapezoidal rule does a better job (!). If you compare with the SciPy implementation you will also observe that an error is given because the accuracy is not reached.

Do the following substitution, and show that the integral can be rewritten as: Estimate the integral once more with the adaptive trapezoidal and Romberg algorithm. Note the greatly improvement in performance for the Romberg method


It always wise to test out different methods, even if we expect that a specific method is supposed to be better it is not always so. Change of integration variable can greatly improve the performance.


Exercise: Gaussian evaluation of 
Gaussian integration is extremely powerful, and should always be considered if speed is an issue. As explained in the compendium the idea behind the Gaussian integration is to approximate the function to be integrated on the domain as a 
polynomial of as large a degree as possible, then the numerical integral of this polynomial will be very close to the integral of the function we are seeking. In this case, considering equation, we can develop similar integration rules as in the compendium, and we choose to be integrated exact: 

It is a bit cumbersome to solve the above equations, but in Python it can be done by g. using SymPy: o Find and and the corresponding weights and 
o Implement the Gaussian integration rule in this case and estimate 

A correct implementation should give you, or an accuracy of. 
